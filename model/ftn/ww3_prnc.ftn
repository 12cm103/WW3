MODULE c_caldat
CONTAINS
!*********************************************************************
INTEGER FUNCTION julday(id,mm,iyyy)
! See numerical recipes 2nd ed. The order of month and day have been swapped!
!*********************************************************************
   IMPLICIT NONE
        INTEGER(KIND=4),    INTENT(in)  :: id,mm,iyyy
   INTEGER(KIND=4), PARAMETER :: IGREG=15+31*(10+12*1582)
   INTEGER(KIND=4) ja,jm,jy
   jy=iyyy
   IF (jy.EQ.0) WRITE(6,*) 'There is no zero year !!'
   IF (jy.LT.0) jy=jy+1
   IF (mm.GT.2) THEN
      jm=mm+1
   ELSE
      jy=jy-1
      jm=mm+13
   ENDIF
   julday=INT(365.25*jy)+int(30.6001*jm)+id+1720995
   IF (id+31*(mm+12*iyyy).GE.IGREG) THEN
      ja=INT(0.01*jy)
      julday=julday+2-ja+INT(0.25*ja)
   ENDIF
   RETURN
END FUNCTION JULDAY

!*********************************************************************
SUBROUTINE caldat(julian,id,mm,iyyy)
! See numerical recipes 2nd ed. The order of month and day have been swapped!
!*********************************************************************
   IMPLICIT NONE
        INTEGER(KIND=4),    INTENT(in)  :: julian
   INTEGER(KIND=4),    INTENT(out) :: id,mm,iyyy
   INTEGER(KIND=4), PARAMETER :: IGREG=2299161
   INTEGER(KIND=4) ja,jalpha,jb,jc,jd,je
   if (julian.GE.IGREG) THEN
      jalpha=INT(((julian-1867216)-0.25)/36524.25)
      ja=julian+1+jalpha-INT(0.25*jalpha)
   ELSE
      ja=julian
   ENDIF
   jb=ja+1524
   jc=INT(6680.+((jb-2439870)-122.1)/365.25)
   jd=365*jc+INT(0.25*jc)
   je=INT((jb-jd)/30.6001)
   id=jb-jd-INT(30.6001*je)
   mm=je-1
   IF (mm.GT.12) mm=mm-12
   iyyy=jc-4715
   IF (mm.GT.2) iyyy=iyyy-1
   IF (iyyy.LE.0) iyyy=iyyy-1
   RETURN
   END SUBROUTINE CALDAT
END MODULE c_caldat
!*********************************************************************



!/ ------------------------------------------------------------------- /
      PROGRAM W3PRNC
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           H. L. Tolman            |
!/                  |             A. Chawla             |
!/                  |             M. Accensi            |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         24-Mar-2011 |
!/                  +-----------------------------------+
!/
!/    14-Jan-1999 : Final FORTRAN 77                    ( version 1.18 )
!/    18-Jan-2000 : Upgrade to FORTRAN 90               ( version 2.00 )
!/    11-Jan-2001 : Flat grid option added              ( version 2.06 )
!/    17-Jul-2001 : Clean-up                            ( version 2.11 )
!/    24-Jan-2002 : Add data for data assimilation.     ( version 2.17 )
!/    30-Apr-2002 : Fix 'AI' bug for 1-D fields.        ( version 2.20 )
!/    24-Apr-2003 : Fix bug for NDAT = 0 in data.       ( version 3.03 )
!/    24-Dec-2004 : Multiple grid version.              ( version 3.06 )
!/    28-Jun-2006 : Adding file name preamble.          ( version 3.09 )
!/    25-Sep-2007 : Switch header of file on or off,    ( version 3.13 )
!/                  Times to file (!/O15) (A. Chawla)
!/    29-May-2009 : Preparing distribution version.     ( version 3.14 )
!/    30-Oct-2009 : Implement run-time grid selection.  ( version 3.14 )
!/                  (W. E. Rogers & T. J. Campbell, NRL)
!/    30-Oct-2009 : Implement curvilinear grid type.    ( version 3.14 )
!/                  (W. E. Rogers & T. J. Campbell, NRL)
!/    15-May-2010 : Add ISI (icebergs and sea ice).     ( version 3.14_Ifremer )   
!/    29-Oct-2010 : Merging 3.14-IFREMER with 4.03      ( version 4.04 )
!/                  (A. Roland and F. Ardhuin) 
!/
!/    Copyright 2009 National Weather Service (NWS),
!/       National Oceanic and Atmospheric Administration.  All rights
!/       reserved.  WAVEWATCH III is a trademark of the NWS. 
!/       No unauthorized use without permission.
!/
!  1. Purpose :
!
!     Pre-processing of the input water level, current, wind and ice
!     fields as well as assimilation data for the generic shell W3SHEL
!     (ww3_shel.ftn).
!
!  2. Method :
!
!     See documented input file.
!
!  3. Parameters :
!
!     Local parameters.
!     ----------------------------------------------------------------
!       NDSI    Int.  Input unit number ("ww3_prnc.inp").
!       NDSDAT  Int.  Unit number for output data file.
!       IFLD    Int.  Integer input type.
!       ITYPE   Int.  Integer input 'format' type.
!       FLTIME  Log.  Time flag for input fields, if false, single
!                     field, time read from NDSI.
!       NAMEF   C*20   +
!       XC      R.A.  Components of input vector field or first
!                     input scalar field
!       YC      R.A.  Components of input vector field or second
!                     input scalar field
!       FX,FY   R.A.  Output fields.
!       ACC     Real  Required interpolation accuracy.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      W3NMOD    Subr. W3GDATMD Set number of model.
!      W3SETG    Subr.   Id.    Point to selected model.
!      W3NDAT    Subr. W3WDATMD Set number of model for wave data.
!      W3SETW    Subr.   Id.    Point to selected model for wave data.
!      W3NOUT    Subr. W3ODATMD Set number of model for output.
!      W3SETO    Subr.   Id.    Point to selected model for output.
!      ITRACE    Subr. W3SERVMD Subroutine tracing initialization.
!      STRACE    Subr.   Id.    Subroutine tracing.
!      NEXTLN    Subr.   Id.    Get next line from input filw
!      EXTCDE    Subr.   Id.    Abort program as graceful as possible.
!      STME21    Subr. W3TIMEMD Convert time to string.
!      INAR2R    Subr. W3ARRYMD Read in an REAL array.
!      INAR2I    Subr.   Id.    Read in an INTEGER array.
!      PRTBLK    Subr.   Id.    Print plot of array.
!      W3IOGR    Subr. W3IOGRMD Reading/writing model definition file.
!      W3FLDO    Subr. W3FLDSMD Opening of WAVEWATCH III generic shell
!                               data file.
!      W3FLDP    Subr.   Id.    Prepare interp. from arbitrary grid.
!      W3FLDG    Subr.   Id.    Reading/writing shell input data.
!      W3FLDD    Subr.   Id.    Reading/writing shell assim. data.
!      W3GSUC    Func. W3GSRUMD Create grid-search-utility object
!      W3GSUD    Subr. W3GSRUMD Destroy grid-search-utility object
!      W3GRMP    Func. W3GSRUMD Compute interpolation weights
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!     None, stand-alone program.
!
!  6. Error messages :
!
!     - Checks on files and reading from file.
!     - Checks on validity of input parameters.
!
!  7. Remarks :
!
!     - Input fields need to be continuous in longitude and latitude.
!
!  8. Structure :
!
!     ----------------------------------------------------
!        1.a  Number of models.
!                   ( W3NMOD , W3NOUT , W3SETG , W3SETO )
!          b  I-O setup.
!          c  Print heading(s).
!        2.   Read model definition file.      ( W3IOGR )
!        3.a  Read major types from input file.
!          b  Check major types.
!          c  Additional input format types and time.
!        4.   Prepare interpolation.
!          a  Longitude - latitude grid
!          b  Grid(s) from file.               ( W3FLDP )
!          c  Initialize fields.
!          d  Input location and format.
!        5    Prepare input and output files.
!          a  Open input file
!          b  Open and prepare output file     ( W3FLDO )
!        6    Until end of file
!          a  Read new time and fields
!          b  Interpolate fields
!          c  Write fields                     ( W3FLDG )
!     ----------------------------------------------------
!
!  9. Switches :
!
!     !/WNT0  = !/WNT1
!     !/WNT1  Correct wind speeds to (approximately) conserve the wind
!             speed over the interpolation box.
!     !/WNT2  Id. energy (USE ONLY ONE !)
!     !/CRT1  Like !/WNT1 for currents.
!     !/CRT2  Like !/WNT2 for currents.
!
!     !/O3    Additional output in fields processing loop.
!     !/O15   Generate file with the times of the processed fields.
!
!     !/S     Enable subroutine tracing.
!     !/T     Enable test output,
!     !/T1    Full interpolation data.
!     !/T1a   Echo of lat-long data in type Fn
!     !/T2    Full input data.
!     !/T3    Print-plot of output data.
!
!     !/NCO   NCEP NCO modifications for operational implementation.
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
      USE CONSTANTS
!/
!     USE W3GDATMD, ONLY: W3NMOD, W3SETG
!/NL1      USE W3ADATMD,ONLY: W3NAUX, W3SETA
      USE W3ODATMD, ONLY: W3NOUT, W3SETO
      USE W3SERVMD, ONLY : ITRACE, NEXTLN, EXTCDE
!/S      USE W3SERVMD, ONLY : STRACE
      USE W3TIMEMD, ONLY : STME21
      USE W3ARRYMD, ONLY : INA2R, INA2I
!/T2      USE W3ARRYMD, ONLY : PRTBLK
!/T3      USE W3ARRYMD, ONLY : PRTBLK
      USE W3IOGRMD, ONLY: W3IOGR
      USE W3FLDSMD, ONLY: W3FLDO, W3FLDP, W3FLDG, W3FLDD
!/
      USE W3GDATMD
      USE W3GSRUMD
      USE W3ODATMD, ONLY: NDSE, NDST, NDSO, FNMPRE

      USE c_caldat
      USE netcdf
!
      IMPLICIT NONE
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      INTEGER                 :: NDSI, NDSM, NDSDAT, NDSTRC, NTRACE,  &
                                 IERR, IFLD, ITYPE, J, IX, IY,        &
                                 TIME(2), NXI, NYI, NXJ, NYJ,         &
                                 MXM, MYM, DATTYP, RECLDT, IDAT,      &
                                 NDAT, NDATMX, JJ, IS(4), JS(4)
      INTEGER                 :: NYB
      INTEGER                 :: ILAND = -999
!/O15      INTEGER                 :: NDSTIME
      INTEGER, ALLOCATABLE    :: IX1(:), IX2(:), IY1(:), IY2(:),      &
                                 IX21(:,:), IX22(:,:), IY21(:,:),     &
                                 IY22(:,:), JX21(:,:), JX22(:,:),     &
                                 JY21(:,:), JY22(:,:), MAPOVR(:,:)
      INTEGER, ALLOCATABLE    :: MASK(:,:)
      TYPE(T_GSU)             :: GSI
!/S      INTEGER, SAVE           :: IENT = 0
!/T2      INTEGER                 :: IXP0, IXPN, IXPWDT = 60
!/T3      INTEGER                 :: IX0, IXN, IXWDT = 60
!/T3      INTEGER, ALLOCATABLE    :: MAPOUT(:,:)
      REAL                    :: X0I, XNI, Y0I, YNI, SXI, SYI, XDIF,  &
                                 ADD, X, Y, FACTOR, EFAC, NODATA, RW(4)
      REAL                    :: ACC = 0.05
      REAL, ALLOCATABLE       :: RX2(:), RY2(:), RD11(:,:), RD21(:,:),&
                                 RD12(:,:), RD22(:,:), XD11(:,:),     &
                                 XD21(:,:), XD12(:,:), XD22(:,:),     &
                                 FX(:,:), FY(:,:), FA(:,:), A1(:,:),  &
                                 A2(:,:), A3(:,:)
      REAL, POINTER           :: ALA(:,:), ALO(:,:)
      REAL, ALLOCATABLE       :: XC(:,:), YC(:,:), AC(:,:), DATA(:,:)
      LOGICAL                 :: INGRID
      LOGICAL                 :: FLSTAB, FLBERG, GLOBX, CLO(2),       &
                                 FLTIME, FLHDR
!/T      LOGICAL                 :: FLMOD
      CHARACTER               :: COMSTR*1, IDFLD*3, IDTYPE*2,         &
                                 IDTIME*23,      &
                                 NAMEF*20
      CHARACTER*12            :: IDSTR1(5)
      CHARACTER*15            :: IDSTR3(3)
      CHARACTER*20            :: IDSTR2(5)
      INTEGER                 :: GTYPEDUM = 0
!
      INTEGER               :: ncid, stat, dimid(4), dimln(4)
      INTEGER, ALLOCATABLE  :: varid(:)
      CHARACTER*10, DIMENSION(:), ALLOCATABLE   :: varname
      CHARACTER*10          :: dimname(4)
      CHARACTER*50          :: timeunits
      REAL(kind=8)          :: dateref, datecur
      REAL(KIND=4)          :: scur, mncur, hcur
      INTEGER               :: i,ITIME, dref, mref, yref, dcur, mcur, ycur
      CHARACTER*14          :: TIME_STR


      EQUIVALENCE              ( NXI , NXJ ) , ( NYI , NYJ )
!/
!/ ------------------------------------------------------------------- /
!/
      DATA IDSTR1 / 'ice         ' , 'water levels' ,                 &
                    'winds       ' , 'currents    ' ,                 &
                    'data        ' /
      DATA IDSTR2 / 'pre-processed file  ' , 'long.-lat. grid     ' , &
                    'grid from file (1)  ' , 'grid from file (2)  ' , &
                    'data (assimilation) ' /
      DATA IDSTR3 / 'mean parameters', '1D spectra     ',             &
                    '2D spectra     ' /
!
!/NCO/!     CALL W3TAGB('WAVEPREP',1998,0007,0050,'NP21   ')
!
!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! 1.a  Set number of models
!
      CALL W3NMOD ( 1, 6, 6 )
      CALL W3SETG ( 1, 6, 6 )
!/NL1      CALL W3NAUX (    6, 6 )
!/NL1      CALL W3SETA ( 1, 6, 6 )
      CALL W3NOUT (    6, 6 )
      CALL W3SETO ( 1, 6, 6 )
!
! 1.b  IO set-up.
!
      NDSI   = 10
      NDSO   =  6
      NDSE   =  6
      NDST   =  6
      NDSM   = 11
      NDSDAT = 12
!/O15      NDSTIME = 13
!
      NDSTRC =  6
      NTRACE = 10
      CALL ITRACE ( NDSTRC, NTRACE )
!
!/NCO/!
!/NCO/! Redo according to NCO
!/NCO/!
!/NCO      NDSI   = 11
!/NCO      NDSO   =  6
!/NCO      NDSE   = NDSO
!/NCO      NDST   = NDSO
!/NCO      NDSM   = 12
!/NCO      NDSDAT = 51
!/NCO      NDSTRC = NDSO
!
! 1.c Print header
!
      WRITE (NDSO,900)
!/S      CALL STRACE (IENT, 'W3PRNC')
!
      J      = LEN_TRIM(FNMPRE)
      OPEN (NDSI,FILE=FNMPRE(:J)//'ww3_prnc.inp',STATUS='OLD',ERR=800,IOSTAT=IERR)
      REWIND (NDSI)
      READ (NDSI,'(A)',END=801,ERR=802,IOSTAT=IERR) COMSTR
      IF (COMSTR.EQ.' ') COMSTR = '$'
      WRITE (NDSO,901) COMSTR
!
!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! 2.  Read model definition file.
!
      CALL W3IOGR ( 'READ', NDSM )
      WRITE (NDSO,902) GNAME
      IF (GTYPE.EQ.UNGTYPE) THEN 
        NYB=NX
      ELSE
        NYB=NY
        END IF
      ALLOCATE ( IX1(NX), IX2(NX), IY1(NYB), IY2(NYB), IX21(NX,NY),     &
                 IX22(NX,NY), IY21(NX,NY), IY22(NX,NY), JX21(NX,NY),  &
                 JX22(NX,NY), JY21(NX,NY),JY22(NX,NY), MAPOVR(NX,NY) )
      ALLOCATE ( RX2(NX), RY2(NYB), RD11(NX,NY), RD21(NX,NY),          &
                 RD12(NX,NY), RD22(NX,NY), XD11(NX,NY), XD21(NX,NY),  &
                 XD12(NX,NY), XD22(NX,NY), FX(NX,NY), FY(NX,NY),      &
                 FA(NX,NY), A1(NX,NY), A2(NX,NY), A3(NX,NY) )
!
!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! 3.a Read types from input file.
!
      CALL NEXTLN ( COMSTR , NDSI , NDSE )
      READ (NDSI,*,END=801,ERR=802,IOSTAT=IERR) IDFLD, IDTYPE, FLTIME, FLHDR
!
! 3.b Check types.
!
      FLSTAB = IDFLD .EQ. 'WNS'
      FLBERG = IDFLD .EQ. 'ISI'
      IF ( IDFLD.EQ.'ICE' .OR. FLBERG ) THEN
          IFLD    = 1
        ELSE IF ( IDFLD.EQ.'LEV' ) THEN
          IFLD    = 2
        ELSE IF ( IDFLD.EQ.'WND' .OR. FLSTAB ) THEN
          IFLD    = 3
        ELSE IF ( IDFLD.EQ.'CUR' ) THEN
          IFLD    = 4
        ELSE IF ( IDFLD.EQ.'DAT' ) THEN
          IFLD    = 5
        ELSE
          WRITE (NDSE,1030) IDFLD
          CALL EXTCDE ( 1 )
        END IF
!
      IF (IDFLD.EQ.'DAT') THEN
          ITYPE   = 5
        ELSE IF (IDTYPE.EQ.'AI') THEN
          ITYPE   = 1
        ELSE IF (IDTYPE.EQ.'LL') THEN
          ITYPE   = 2
        ELSE
          WRITE (NDSE,1031) IDTYPE
          CALL EXTCDE ( 2 )
        END IF
!
!/T      IF (ITYPE.NE.1 .AND. ITYPE.NE.5) WRITE (NDST,9000) ACC
!
      WRITE (NDSO,930) IDSTR1(IFLD), IDSTR2(ITYPE)
      IF ( ITYPE.NE.1 ) THEN
!/WNT0          IF (IFLD.EQ.3) WRITE (NDSO,1930)
!/WNT1          IF (IFLD.EQ.3) WRITE (NDSO,1930)
!/WNT2          IF (IFLD.EQ.3) WRITE (NDSO,2930)
!/CRT1          IF (IFLD.EQ.4) WRITE (NDSO,1930)
!/CRT2          IF (IFLD.EQ.4) WRITE (NDSO,2930)
        END IF
      IF ( FLBERG ) WRITE (NDSO,938)
      IF ( FLSTAB ) WRITE (NDSO,939)
!
! 3.c Additional input for format types and time
! ... time
!
      IF (.NOT. FLTIME) THEN
          CALL NEXTLN ( COMSTR , NDSI , NDSE )
          READ (NDSI,*,END=801,ERR=802,IOSTAT=IERR) TIME
          IF (TIME(1).LT.10000000) THEN
              WRITE (NDSE,1035) TIME
              CALL EXTCDE ( 4 )
            END IF
          CALL STME21 ( TIME , IDTIME )
          WRITE (NDSO,931) IDTIME
        END IF
!
      J = 1
      IF ( FLAGLL ) THEN
          FACTOR = 1.
        ELSE
          FACTOR = 1.E-3
        END IF

!
! 3.d Read Input netcdf file
!
      WRITE (NDSO,1932)
      CALL NEXTLN ( COMSTR , NDSI , NDSE )
      READ (NDSI,*,END=801,ERR=802,IOSTAT=IERR) NAMEF

      J = LEN_TRIM(FNMPRE)
  	  stat=nf90_open(path=FNMPRE(:J)//NAMEF,mode=nf90_nowrite,ncid=ncid)
    	IF ( stat/=nf90_noerr ) call handle_err(stat)

      dimname=(/"time","longitude","latitude","level"/)
      DO i=1,4
        stat=nf90_inq_dimid(ncid,dimname(i),dimid(i))
      	IF ( stat/=nf90_noerr ) call handle_err(stat)
        stat=nf90_inquire_dimension(ncid,dimid(i),len=dimln(i))
      	IF ( stat/=nf90_noerr ) call handle_err(stat)
        END DO

      IF (IDFLD .EQ. 'ICE') THEN
          ALLOCATE(varname(4),varid(4))
          varname=(/"time","longitude","latitude","ICE"/)
        ELSE IF (IDFLD .EQ. 'LEV') THEN
          ALLOCATE(varname(4),varid(4))
          varname=(/"time","longitude","latitude","XE"/)
        ELSE IF (IDFLD .EQ. 'WND') THEN
          ALLOCATE(varname(5),varid(5))
          varname=(/"time","longitude","latitude","U10","V10"/)
        ELSE IF (IDFLD .EQ. 'WNDS') THEN 
          ALLOCATE(varname(6),varid(6))
          varname=(/"time","longitude","latitude","U10","V10","WTMP"/)
        ELSE IF (IDFLD .EQ. 'CUR') THEN
          ALLOCATE(varname(5),varid(5))
          varname=(/"time","longitude","latitude","U","V"/)
        ELSE IF (IDFLD .EQ. 'DAT') THEN
          ALLOCATE(varname(4), varid(4))
          varname=(/"time","longitude","latitude","DAT"/)
        END IF

      DO i=1,size(varid)
        stat=nf90_inq_varid(ncid,varname(i),varid(i))
      	IF ( stat/=nf90_noerr ) call handle_err(stat)
        END DO

      stat=nf90_get_att(ncid,varid(1),"units",timeunits)
      read(timeunits(15:18),'(I4.4)') yref
      read(timeunits(20:21),'(I2.2)') mref
      read(timeunits(23:24),'(I2.2)') dref
      dateref=julday(dref,mref,yref)

      NXI = dimln(2)
      NYI = dimln(3)
      stat=nf90_get_var(ncid,varid(2),X0I,start=(/1/))
      stat=nf90_get_var(ncid,varid(2),XNI,start=(/NXI/))
      stat=nf90_get_var(ncid,varid(3),Y0I, start=(/1/))
      stat=nf90_get_var(ncid,varid(3),YNI, start=(/NYI/))



!
! ... type 1
!
      IF (ITYPE.EQ.1) THEN
         NXI    = NX
         NYI    = NY
         ALLOCATE ( MASK(NXI,NYI) )
         MASK   = 1
         IF(GTYPE .EQ. UNGTYPE) THEN
            WRITE (NDSO,932) NXI, NYI
            WRITE (NDSO,933) FACTOR*X0, FACTOR*MAXX,      &
                             FACTOR*Y0, FACTOR*MAXY
          ELSE 
            WRITE (NDSO,932) NXI, NYI
            IF ( FLAGLL ) THEN
               WRITE (NDSO,933) FACTOR*XGRD(1,1), FACTOR*XGRD(NY,NX),  &
                                FACTOR*YGRD(1,1), FACTOR*YGRD(NY,NX)
            ELSE
              WRITE (NDSO,733) FACTOR*XGRD(1,1), FACTOR*XGRD(NY,NX),  &
                               FACTOR*YGRD(1,1), FACTOR*YGRD(NY,NX)
              END IF
            END IF
!
! ... type 2
!
        ELSE IF (ITYPE.EQ.2) THEN
!
          IF (NXI.LT.2 .OR. NYI.LT.2) THEN
              WRITE (NDSE,1036) NXI, NYI
              CALL EXTCDE ( 5 )
            END IF
          ALLOCATE ( MASK(NXI,NYI) )
          MASK   = 1
          WRITE (NDSO,932) NXI, NYI
          WRITE (NDSO,933) FACTOR*X0I, FACTOR*XNI,                    &
                           FACTOR*Y0I, FACTOR*YNI
!
! ... type 5
!
        ELSE IF (ITYPE.EQ.5) THEN
          CALL NEXTLN ( COMSTR , NDSI , NDSE )
          READ (NDSI,*,END=801,ERR=802,IOSTAT=IERR)                   &
                DATTYP, RECLDT, NODATA
          IF (DATTYP.LT.0 .OR. DATTYP.GT.2) THEN
              WRITE (NDSE,1033) DATTYP
              CALL EXTCDE ( 6 )
            END IF
          IF (RECLDT.LE.0) THEN
              WRITE (NDSE,1034) RECLDT
              CALL EXTCDE ( 7 )
            END IF
          WRITE (NDSO,934) IDSTR3(DATTYP+1), RECLDT, NODATA
          WRITE (IDFLD,935) DATTYP
          DEALLOCATE ( IX1, IX2, IY1, IY2, IX21, IX22, IY21, IY22,    &
                       JX21, JX22, JY21,JY22, MAPOVR, RX2, RY2, RD11, &
                       RD21, RD12, RD22, XD11, XD21, XD12, XD22,      &
                       FX, FY, FA, A1, A2, A3 )
!
! ... types 3 and 4 ... in preprocessing loop ....
!
        END IF
!
!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! 4   Prepare interpolation.
!
      WRITE (NDSO,940)
!
! 4.a Longitude - latitude grid
!
      IF (ITYPE.EQ.2) THEN
        WRITE (NDSO,941)
!
! ... Check and adjust ranges
!
        SXI    = (XNI-X0I)/REAL(NXI-1)
        SYI    = (YNI-Y0I)/REAL(NYI-1)
        IF (GTYPE .LT. UNGTYPE) THEN
          IF (FLAGLL) THEN
            GLOBX  = (ABS(ABS(REAL(NXI)*SXI)-360.) .LT. 0.1*ABS(SXI))
          ELSE
            GLOBX  = .FALSE.
            END IF
          END IF
        IF ( ASSOCIATED(ALA) ) THEN
          DEALLOCATE ( ALA, ALO )
          NULLIFY ( ALA, ALO )
          END IF
        ALLOCATE ( ALA(NXI,NYI), ALO(NXI,NYI) )
        DO IY=1, NYI
          DO IX=1, NXI
            ALO(IX,IY) = X0I + REAL(IX-1)*SXI
            ALA(IX,IY) = Y0I + REAL(IY-1)*SYI
            END DO
          END DO
!
! ... create grid search utility
!
        GSI = W3GSUC( .TRUE., FLAGLL, GLOBX, NXI, NYI, ALO, ALA )
!
        IF (FLAGLL) THEN
          IF (ABS(X0I-XNI) .GT. 360.+0.5*ABS(SXI)) GOTO 840
          IF ( GLOBX ) THEN
            XDIF   = X0 - X0I
            IF ( XDIF .GE. 0. ) THEN
              ADD    = REAL(INT(XDIF/360.))
            ELSE
              ADD    = -1 + REAL(INT(XDIF/360.))
              END IF
          ELSE
            XDIF   = - 0.5*(XNI+X0I) + 0.5*(2.*X0+REAL(NX-1)*SX)
            IF (GTYPE .EQ. 3)  XDIF   = - 0.5*(XNI+X0I) + 0.5*(2.*MAXX)
            ADD    = REAL(NINT(XDIF/360.))
            END IF  ! GLOBX
!
          ADD    = ADD * 360.
          X0I    = X0I + ADD
          XNI    = XNI + ADD
          IF (Y0I.LT.-90 .OR. YNI.GT.90.) GOTO 841
          END IF ! FLAGLL 
!
!/T              WRITE (NDST,9040) X0I, XNI, SXI, GLOBX, Y0I, YNI, SYI
!
! ... Calculate 1-D interpolation data longitudes
!
!/T              WRITE (NDST,9041) 'LON / X'
!
        IF ( GLOBX ) THEN
!
!FA This is not consistent with curviliear grids: should have a double loop on IX and IY
!   and use X=XGRD and Y=YGRD ... 
!
          DO IX=1, NX
            IF (GTYPE .EQ. 3) THEN
              X = XYB(IX,1)
            ELSE
              X = X0 + REAL(IX-1)*SX
              END IF 
            IX1(IX) = 1 + INT((X-X0I)/SXI)
            RX2(IX) = (X-X0I)/SXI - REAL(IX1(IX)-1)
            IF (IX1(IX).GT.NXI) IX1(IX) = 1 + MOD(IX1(IX)-1,NXI)
            IF (IX1(IX).EQ.NXI) THEN
              IX2(IX) = 1
            ELSE
              IX2(IX) = IX1(IX) + 1
              END IF
!/T                    WRITE (NDST,9042) IX, FACTOR*X, IX1(IX), IX2(IX),  &
!/T                                      FACTOR*(X0I+REAL(IX1(IX)-1)*SXI),&
!/T                                      FACTOR*(X0I+REAL(IX2(IX)-1)*SXI),&
!/T                                      RX2(IX), ' '
            END DO
        ELSE ! GLOBX 
!
!FA This is not consistent with curviliear grids: should have a double loop on IX and IY
!
          IY=1
          DO IX=1, NX
            X=XGRD(IY,IX)
            IX1(IX) = 1 + INT((X-X0I)/SXI)
            IX1(IX) = MAX ( 1 , MIN(IX1(IX),NXI-1) )
            IX2(IX) = IX1(IX) + 1
            RX2(IX) = (X-X0I)/SXI - REAL(IX1(IX)-1)
!/T                WRITE (NDST,9042) IX, FACTOR*X, IX1(IX), IX2(IX),  &
!/T                                      FACTOR*(X0I+REAL(IX1(IX)-1)*SXI),&
!/T                                      FACTOR*(X0I+REAL(IX2(IX)-1)*SXI),&
!/T                                      RX2(IX), ' '
!/T                    FLMOD  = .FALSE.
!
            IF (IX1(IX).EQ.1 .AND. RX2(IX).LT.ACC) THEN
              IF (RX2(IX).LT.-ACC) THEN
                WRITE (NDSO,1043) X
              ELSE IF (RX2(IX).LT.0.) THEN
                RX2(IX) = 0.
!/T                 FLMOD  = .TRUE.
                END IF
              END IF
!
            IF (IX2(IX).EQ.NXI .AND. RX2(IX).GT.1.-ACC) THEN
              IF (RX2(IX).GT.1.+ACC) THEN
                WRITE (NDSO,1043) X
              ELSE IF (RX2(IX).GT.1.) THEN
                RX2(IX) = 1.
!/T                       FLMOD  = .TRUE.
                END IF
              END IF
!
!/T                    IF ( FLMOD ) WRITE (NDST,9042)                      &
!/T                                       IX, FACTOR*X, IX1(IX), IX2(IX),  &
!/T                                       FACTOR*(X0I+REAL(IX1(IX)-1)*SXI),&
!/T                                       FACTOR*(X0I+REAL(IX2(IX)-1)*SXI),&
!/T                                       RX2(IX), '<-- MOD'
!
            END DO
          END IF ! GLOBX
!
! ... Calculate 1-D interpolation data latitudes
!
!/T              WRITE (NDST,9041) 'LAT / Y'
!FA This shoudl go away when the single loops on 1,NX and 1,NY are replaced by a double loop
        IF (GTYPE .LT. UNGTYPE) THEN 
          NYB = NY 
        ELSE IF (GTYPE .EQ. UNGTYPE) THEN
          NYB = NX
          END IF
!
        DO IY=1, NYB
          IF (GTYPE .LT. UNGTYPE) THEN  
            Y = Y0 + REAL(IY-1)*SY
          ELSE
            Y = XYB(IY,2)
            END IF
          IY1(IY) = 1 + INT((Y-Y0I)/SYI)
          IY1(IY) = MAX ( 1 , MIN(IY1(IY),NYI-1) )
          IY2(IY) = IY1(IY) + 1
          RY2(IY) = (Y-Y0I)/SYI - REAL(IY1(IY)-1)
!
!/T                WRITE (NDST,9042) IY, FACTOR*Y, IY1(IY), IY2(IY),     &
!/T                                  FACTOR*(Y0I+REAL(IY1(IY)-1)*SYI),   &
!/T                                  FACTOR*(Y0I+REAL(IY2(IY)-1)*SYI),   &
!/T                                  RY2(IY), ' '
!/T                FLMOD  = .FALSE.
!
          IF (IY1(IY).EQ.1 .AND. RY2(IY).LT.ACC) THEN
            IF (RY2(IY).LT.-ACC) THEN
              WRITE (NDSO,1044) Y
            ELSE IF (RY2(IY).LT.0.) THEN
              RY2(IY) = 0.
!/T                  FLMOD  = .TRUE.
              END IF
            END IF
!
          IF (IY2(IY).EQ.NYI .AND. RY2(IY).GT.1.-ACC) THEN
            IF (RY2(IY).GT.1.+ACC) THEN
              WRITE (NDSO,1044) Y
            ELSE IF (RY2(IY).GT.1.) THEN
              RY2(IY) = 1.
!/T                       FLMOD  = .TRUE.
              END IF
            END IF
!
!/T                IF ( FLMOD ) WRITE (NDST,9042)                        &
!/T                                   IY, FACTOR*Y, IY1(IY), IY2(IY),    &
!/T                                   FACTOR*(Y0I+REAL(IY1(IY)-1)*SYI),  &
!/T                                   FACTOR*(Y0I+REAL(IY2(IY)-1)*SYI),  &
!/T                                   RY2(IY), '<-- MOD'
!
          END DO ! NYB
!
! ... Compose 2-D interpolation data
!
!/T1              WRITE (NDST,9045)
        IF (GTYPE .NE. UNGTYPE) THEN
          DO IY=1,NY
            DO IX=1,NX
              INGRID = W3GRMP( GSI, XGRD(IY,IX), YGRD(IY,IX),      &
                               IS, JS, RW )
              IF ( .NOT.INGRID ) THEN
                  WRITE(NDSO,1042) IX, IY, XGRD(IY,IX), YGRD(IY,IX)
                  CYCLE
                END IF
              IX21(IX,IY) = IS(1)
              IX22(IX,IY) = IS(2)
              IY21(IX,IY) = JS(1)
              IY22(IX,IY) = JS(4)
              RD11(IX,IY) = RW(1)
              RD21(IX,IY) = RW(2)
              RD12(IX,IY) = RW(4)
              RD22(IX,IY) = RW(3)
!/T1                  WRITE (NDST,9046) IX, IY,                           &
!/T1                    IX21(IX,IY),IX22(IX,IY),IY21(IX,IY),IY22(IX,IY),  &
!/T1                    RD11(IX,IY),RD12(IX,IY),RD21(IX,IY),RD22(IX,IY), EFAC
              END DO
            END DO
        ELSE 
          DO IX=1,NX
            IX21(IX,1) =   IX1(IX)
            IX22(IX,1) =   IX2(IX)
            IY21(IX,1) =   IY1(IX)
            IY22(IX,1) =   IY2(IX)
            EFAC       = SQRT ( MAX(0.,ABS(RX2(IX)-0.5)-0.5)**2 +  &
                                MAX(0.,ABS(RY2(IX)-0.5)-0.5)**2 )
            EFAC        = 1. / ( 1. + 0.25*EFAC**2 )
            RD11(IX,1) = EFAC * (1.-RX2(IX)) * (1.-RY2(IX))
            RD21(IX,1) = EFAC *    RX2(IX)   * (1.-RY2(IX))
            RD12(IX,1) = EFAC * (1.-RX2(IX)) *    RY2(IX)
            RD22(IX,1) = EFAC *    RX2(IX)   *    RY2(IX)
            END DO 
          END IF ! GTYPE .NE. UNGTYPE
!
        CALL W3GSUD( GSI )
        DEALLOCATE ( ALA, ALO )
        NULLIFY ( ALA, ALO )

        END IF ! ITYPE.EQ.2

!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! 5   Prepare files
!
! 5.a Open and prepare output file
!
      WRITE (NDSO,971)
      J = LEN_TRIM(FNMPRE)
      IF ( ITYPE .NE. 5 ) THEN
          CALL W3FLDO ( 'WRITE', IDFLD, NDSDAT, NDST, NDSE,           &
               NX, NY, GTYPE, IERR, FPRE=FNMPRE(:J),                  &
               FHDR=FLHDR )
        ELSE
          CALL W3FLDO ( 'WRITE', IDFLD, NDSDAT, NDST, NDSE,           &
               RECLDT, 0, GTYPEDUM, IERR, FPRE=FNMPRE(:J) )
        END IF
!
! 5.c Initialize fields
!
      IF ( ITYPE .NE. 5 ) THEN
          FX = 0.
          FY = 0.
          FA = 0.
          MXM = NXJ
          MYM = NYJ
          ALLOCATE ( XC(MXM,MYM), YC(MXM,MYM), AC(MXM,MYM) )
          XC = 0.
          YC = 0.
          AC = 0.
        END IF
!
!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! 6   Begin loop over input fields
!
!/O15      J      = LEN_TRIM(FNMPRE)
!/O15      OPEN (NDSTIME,FILE=FNMPRE(:J)//'times.'//IDFLD,      &
!/O15            ERR=870,IOSTAT=IERR )
!
      WRITE (NDSO,972)
      DO ITIME=1,dimln(1)
!
! 6.a Read new time and fields
!
        IF ( FLTIME ) THEN
!
            stat=nf90_get_var(ncid,varid(1),datecur,start=(/ITIME/))
            IF ( stat/=nf90_noerr ) call handle_err(stat)
            datecur=datecur/86400.
            datecur=dateref+datecur
            call caldat(int(datecur),dcur,mcur,ycur)

      			hcur=(datecur-int(datecur))*24
      			mncur=(hcur-int(hcur))*60
          	scur=(mncur-int(mncur))*60
            write(TIME_STR,'(I4.4,5I2.2)') int(ycur), int(mcur), int(dcur), &
                                          int(hcur), int(mncur), int(scur)
            read(TIME_STR(1:8),'(I8.8)') TIME(1)
            read(TIME_STR(9:14),'(I6.6)') TIME(2)

          END IF
!
        CALL STME21 ( TIME , IDTIME )
        WRITE (NDSO,973) IDTIME
!/O15        WRITE (NDSTIME, 979, ERR=871,IOSTAT=IERR) TIME
!/O3        WRITE (NDSO,974)
!
! ... Input
!
        IF ( ITYPE .NE. 5 ) THEN

            stat=nf90_get_var(ncid,varid(4),XC,start=(/1,1,ITIME/),count=(/MXM,MYM,1/))


!
!/T2            WRITE (NDST,9060) 1
!/T2            IXP0   = 1
!/T2            IXPN   = MIN ( IXP0+IXPWDT-1 , NXJ(1) )
!/T2            DO
!/T2              CALL PRTBLK ( NDST, NXJ(1), NYJ(1), MXM, XC, MASK, 0, 0.,&
!/T2                            IXP0, IXPN, 1, 1, NYJ(1), 1, 'Field 1', ' ')
!/T2              IF (IXPN.NE.NXJ(1)) THEN
!/T2                  IXP0    = IXP0 + IXPWDT
!/T2                  IXPN    = MIN ( IXPN+IXPWDT , NXJ(1) )
!/T2                ELSE
!/T2                  EXIT
!/T2                END IF
!/T2              END DO
!
            IF (IFLD.GE.3 .OR. FLBERG) THEN

                stat=nf90_get_var(ncid,varid(5),YC,start=(/1,1,ITIME/),count=(/MXM,MYM,1/))

                !CALL INA2R (YC, MXM, MYM, 1, NXJ(2), 1, NYJ(2),       &
                !            NDSF(2), NDST, NDSE, IDFMF(2), FORMF(2),  &
                !            IDLAF(2), 1., 0.)
!
!/T2                WRITE (NDST,9060) 2
!/T2                IXP0   = 1
!/T2                IXPN   = MIN ( IXP0+IXPWDT-1 , NXJ(2) )
!/T2                DO
!/T2                  CALL PRTBLK ( NDST, NXJ(2), NYJ(2), MXM, YC, MASK, 0, 0., &
!/T2                                IXP0, IXPN, 1, 1, NYJ(2), 1, 'Field 2', ' ')
!/T2                  IF (IXPN.NE.NXJ(2)) THEN
!/T2                      IXP0    = IXP0 + IXPWDT
!/T2                      IXPN    = MIN ( IXPN+IXPWDT , NXJ(2) )
!/T2                    ELSE
!/T2                      EXIT
!/T2                    END IF
!/T2                  END DO
!
                IF (FLSTAB) THEN

                    stat=nf90_get_var(ncid,varid(6),AC,start=(/1,1,ITIME/),count=(/MXM,MYM,1/))


                    !CALL INA2R (AC, MXM, MYM, 1, NXJ(2), 1, NYJ(2),   &
                    !   NDSF(2), NDST, NDSE, IDFMF(2), FORMF(2),       &
                    !   IDLAF(2), 1., 0. )
!
!/T2                    WRITE (NDST,9060) 3
!/T2                    IXP0   = 1
!/T2                    IXPN   = MIN ( IXP0+IXPWDT-1 , NXJ(2) )
!/T2                    DO
!/T2                      CALL PRTBLK ( NDST, NXJ(2), NYJ(2), MXM, AC, MASK, 0,&
!/T2                            0., IXP0, IXPN, 1,1, NYJ(2), 1, 'Field 3', ' ')
!/T2                      IF (IXPN.NE.NXJ(2)) THEN
!/T2                          IXP0    = IXP0 + IXPWDT
!/T2                          IXPN    = MIN ( IXPN+IXPWDT , NXJ(2) )
!/T2                        ELSE
!/T2                          EXIT
!/T2                        END IF
!/T2                      END DO
!
                  END IF
!
              END IF

          ELSE  ! ITYPE .NE. 5
!
            WRITE(NDSO,*) "ITYPE5 TO DO"
            !READ (NDSF(1),*,END=862,ERR=862,IOSTAT=IERR) NDAT

!/O3            WRITE (NDSO,975) NDAT
            !IF ( NDAT.GT.0 ) THEN
                !ALLOCATE ( DATA(RECLDT,NDAT) )
                !DO IDAT=1, NDAT
                  !READ (NDSF(1),*,END=863,ERR=863,IOSTAT=IERR) DATA(:,IDAT)
                  !END DO
              !END IF
!
!/T2            WRITE (NDST,9061)
!/T2            DO IDAT=1, NDAT
!/T2              IX     = MIN(6,RECLDT)
!/T2              WRITE (NDST,9062) IDAT, DATA(1:IX,IDAT)
!/T2              IF ( IX.LT.RECLDT ) WRITE (NDST,9063) DATA(IX+1:,:)
!/T2              END DO
!
          END IF
!
! 6.b Interpolate fields
! ... No interpolation, type AI (should not use array syntax !!!)
!
        IF (ITYPE.EQ.1) THEN
!
            IF (( IFLD.LE.2 ).AND.( .NOT. FLBERG )) THEN
                DO IY=1, NY
                  DO IX=1, NX
                    FA(IX,IY) = XC(IX,IY)
                    END DO
                  END DO
              ELSE
                DO IY=1, NY
                  DO IX=1, NX
                    FX(IX,IY) = XC(IX,IY)
                    FY(IX,IY) = YC(IX,IY)
                    FA(IX,IY) = AC(IX,IY)
                    END DO
                  END DO
              END IF
!
          ELSE IF (ITYPE.EQ.2) THEN
!
! ... single-component fields
!
!/O3            WRITE (NDSO,976) ' '
            IF (( IFLD.LE.2 ).AND.( .NOT. FLBERG )) THEN
!
              DO IY=1,NY
                DO IX=1,NX
                  FA(IX,IY)                                         &
                        = RD11(IX,IY) * XC(IX21(IX,IY),IY21(IX,IY)) &
                        + RD21(IX,IY) * XC(IX22(IX,IY),IY21(IX,IY)) &
                        + RD12(IX,IY) * XC(IX21(IX,IY),IY22(IX,IY)) &
                        + RD22(IX,IY) * XC(IX22(IX,IY),IY22(IX,IY))
                  END DO
                END DO
!
!
! ... Two-component fields
!
              ELSE
!
                DO IY=1,NY
                  DO IX=1,NX
                    FX(IX,IY)                                         &
                          = RD11(IX,IY) * XC(IX21(IX,IY),IY21(IX,IY)) &
                          + RD21(IX,IY) * XC(IX22(IX,IY),IY21(IX,IY)) &
                          + RD12(IX,IY) * XC(IX21(IX,IY),IY22(IX,IY)) &
                          + RD22(IX,IY) * XC(IX22(IX,IY),IY22(IX,IY))
                    FY(IX,IY)                                         &
                          = RD11(IX,IY) * YC(IX21(IX,IY),IY21(IX,IY)) &
                          + RD21(IX,IY) * YC(IX22(IX,IY),IY21(IX,IY)) &
                          + RD12(IX,IY) * YC(IX21(IX,IY),IY22(IX,IY)) &
                          + RD22(IX,IY) * YC(IX22(IX,IY),IY22(IX,IY))
                    FA(IX,IY)                                         &
                          = RD11(IX,IY) * AC(IX21(IX,IY),IY21(IX,IY)) &
                          + RD21(IX,IY) * AC(IX22(IX,IY),IY21(IX,IY)) &
                          + RD12(IX,IY) * AC(IX21(IX,IY),IY22(IX,IY)) &
                          + RD22(IX,IY) * AC(IX22(IX,IY),IY22(IX,IY))
                    A1(IX,IY) = MAX ( 1.E-10 ,                        &
                                  SQRT( FX(IX,IY)**2 + FY(IX,IY)**2 ) )
                    A2(IX,IY)                                         &
                 = RD11(IX,IY) * SQRT(XC(IX21(IX,IY),IY21(IX,IY))**2  &
                                     +YC(IX21(IX,IY),IY21(IX,IY))**2) &
                 + RD21(IX,IY) * SQRT(XC(IX22(IX,IY),IY21(IX,IY))**2  &
                                     +YC(IX22(IX,IY),IY21(IX,IY))**2) &
                 + RD12(IX,IY) * SQRT(XC(IX21(IX,IY),IY22(IX,IY))**2  &
                                     +YC(IX21(IX,IY),IY22(IX,IY))**2) &
                 + RD22(IX,IY) * SQRT(XC(IX22(IX,IY),IY22(IX,IY))**2  &
                                     +YC(IX22(IX,IY),IY22(IX,IY))**2)
                    A3(IX,IY) = SQRT (                                &
                     RD11(IX,IY) * ( XC(IX21(IX,IY),IY21(IX,IY))**2   &
                                   + YC(IX21(IX,IY),IY21(IX,IY))**2 ) &
                   + RD21(IX,IY) * ( XC(IX22(IX,IY),IY21(IX,IY))**2   &
                                   + YC(IX22(IX,IY),IY21(IX,IY))**2 ) &
                   + RD12(IX,IY) * ( XC(IX21(IX,IY),IY22(IX,IY))**2   &
                                   + YC(IX21(IX,IY),IY22(IX,IY))**2 ) &
                   + RD22(IX,IY) * ( XC(IX22(IX,IY),IY22(IX,IY))**2   &
                                   + YC(IX22(IX,IY),IY22(IX,IY))**2 ) )
                    END DO
                  END DO
!
! ... Winds, correct for velocity or energy conservation
!
!/WNT1                IF (IFLD.EQ.3) THEN
!/WNT1                    DO IY=1,NY
!/WNT1                      DO IX=1,NX
!/WNT1                        FACTOR = MIN ( 1.5 , A2(IX,IY)/A1(IX,IY) )
!/WNT1                        FX(IX,IY) = FACTOR * FX(IX,IY)
!/WNT1                        FY(IX,IY) = FACTOR * FY(IX,IY)
!/WNT1                        END DO
!/WNT1                      END DO
!/WNT1                  END IF
!
!/WNT2                IF (IFLD.EQ.3) THEN
!/WNT2                    DO IY=1,NY
!/WNT2                      DO IX=1,NX
!/WNT2                        FACTOR = MIN ( 1.5 , A3(IX,IY)/A1(IX,IY) )
!/WNT2                        FX(IX,IY) = FACTOR * FX(IX,IY)
!/WNT2                        FY(IX,IY) = FACTOR * FY(IX,IY)
!/WNT2                        END DO
!/WNT2                      END DO
!/WNT2                  END IF
!
! ... Currents, correct for velocity or energy conservation
!
!/CRT1                IF (IFLD.EQ.4) THEN
!/CRT1                    DO IY=1,NY
!/CRT1                      DO IX=1,NX
!/CRT1                        FACTOR = MIN ( 1.5 , A2(IX,IY)/A1(IX,IY) )
!/CRT1                        FX(IX,IY) = FACTOR * FX(IX,IY)
!/CRT1                        FY(IX,IY) = FACTOR * FY(IX,IY)
!/CRT1                        END DO
!/CRT1                      END DO
!/CRT1                  END IF
!
!/CRT2                IF (IFLD.EQ.4) THEN
!/CRT2                    DO IY=1,NY
!/CRT2                      DO IX=1,NX
!/CRT2                        FACTOR = MIN ( 1.5 , A3(IX,IY)/A1(IX,IY) )
!/CRT2                        FX(IX,IY) = FACTOR * FX(IX,IY)
!/CRT2                        FY(IX,IY) = FACTOR * FY(IX,IY)
!/CRT2                        END DO
!/CRT2                      END DO
!/CRT2                 END IF
!
              END IF
!
          END IF
!
! ... Test output
!
!/T3        IF ( .NOT. ALLOCATED(MAPOUT) ) ALLOCATE ( MAPOUT(NX,NY) )
!/T3        WRITE (NDST,9065)
!/T3        DO IX=1, NX
!/T3          DO IY=1, NY
!/T3            MAPOUT(IX,IY) = MAPSTA(IY,IX)
!/T3            END DO
!/T3          END DO
!/T3        IX0    = 1
!/T3        IXN    = MIN ( IX0+IXWDT-1 , NX )
!/T3        DO
!/T3          IF (IFLD.EQ.1) THEN
!/T3              CALL PRTBLK (NDSO, NX, NY, NX, FA, MAPOUT, 0, 0.,   &
!/T3                      IX0, IXN, 1, 1, NY, 1, 'Fraction ice', '(-)')
!/T3              IF ( FLBERG )                                       &
!/T3              CALL PRTBLK (NDSO, NX, NY, NX, FA, MAPOUT, 0, 0.,   &
!/T3                      IX0, IXN, 1, 1, NY, 1, 'Iceberg a', '0.1/km')
!/T3            ELSE IF (IFLD.EQ.2) THEN
!/T3              CALL PRTBLK (NDSO, NX, NY, NX, FA, MAPOUT, 0, 0.,   &
!/T3                      IX0, IXN, 1, 1, NY, 1, 'Water level', 'm')
!/T3            ELSE
!/T3              CALL PRTBLK (NDSO, NX, NY, NX, FX, MAPOUT, 0, 0.,   &
!/T3                      IX0, IXN, 1, 1, NY, 1, 'Cart. X-comp', 'm/s')
!/T3              CALL PRTBLK (NDSO, NX, NY, NX, FY, MAPOUT, 0, 0.,   &
!/T3                      IX0, IXN, 1, 1, NY, 1, 'Cart. Y-comp', 'm/s')
!/T3              IF ( FLSTAB )                                       &
!/T3              CALL PRTBLK (NDSO, NX, NY, NX, FA, MAPOUT, 0, 0.,   &
!/T3                      IX0, IXN, 1, 1, NY, 1, 'Tair-Tsea', 'degr')
!/T3            END IF
!/T3          IF (IXN.NE.NX) THEN
!/T3              IX0    = IX0 + IXWDT
!/T3              IXN    = MIN ( IXN+IXWDT , NX )
!/T3            ELSE
!/T3              EXIT
!/T3            END IF
!/T3          END DO
!
! 6.c Write fields
!
        IF ( ITYPE .NE. 5 ) THEN
!/O3            WRITE (NDSO,977)
            CALL W3FLDG ('WRITE', IDFLD, NDSDAT, NDST, NDSE, NX, NY,  &
                         NX, NY, TIME, TIME, TIME, FX, FY, FA, TIME,  &
                         FX, FY, FA, IERR)

          !ELSE IF ( ITYPE .EQ. 5 ) THEN
            !IF ( NDAT .EQ. 0 ) THEN
!/O3                WRITE (NDSO,978)
              !ELSE
!/O3                WRITE (NDSO,977)
                !CALL W3FLDD ('WRITE', IDFLD, NDSDAT, NDST, NDSE, TIME,&
                !             TIME, RECLDT, NDAT, IDAT, DATA, IERR )
                !DEALLOCATE ( DATA )
              !END IF
          END IF
        IF (IERR.NE.0) CALL EXTCDE ( 30 )
!
        END DO
!
!     End loop over input fields
!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
      GOTO 888
!
! Error escape locations
!
  800 CONTINUE
      WRITE (NDSE,1000) IERR
      CALL EXTCDE ( 40 )
!
  801 CONTINUE
      WRITE (NDSE,1001)
      CALL EXTCDE ( 41 )
!
  802 CONTINUE
      WRITE (NDSE,1002) IERR
      CALL EXTCDE ( 42 )
!
  837 CONTINUE
      WRITE (NDSE,1037) NDSI
      CALL EXTCDE ( 43 )
!
  840 CONTINUE
      WRITE (NDSE,1040) X0I, XNI
      CALL EXTCDE ( 45 )
!
  841 CONTINUE
      WRITE (NDSE,1041) Y0I, YNI
      CALL EXTCDE ( 46 )
!
  845 CONTINUE
      WRITE (NDSE,1045) IERR
      CALL EXTCDE ( 47 )
!
  846 CONTINUE
      WRITE (NDSE,1046) IERR
      CALL EXTCDE ( 48 )
!
  860 CONTINUE
      WRITE (NDSE,1060) J, IERR
      CALL EXTCDE ( 50 )
!
  862 CONTINUE
      WRITE (NDSE,1062) IERR
      CALL EXTCDE ( 52 )
!
  863 CONTINUE
      WRITE (NDSE,1063) IDAT, IERR
      CALL EXTCDE ( 53 )
!
!/O15  870 CONTINUE
!/O15      WRITE (NDSE,1070) IDFLD, IERR
!/O15      CALL EXTCDE ( 54 )
!
!/O15  871 CONTINUE
!/O15      WRITE (NDSE,1071) IDTIME, IERR
!/O15      CALL EXTCDE ( 54 )
!
  888 CONTINUE
      WRITE (NDSO,999)
!
!/NCO/!     CALL W3TAGE('WAVEPREP')
!
! Formats
!
  900 FORMAT (/15X,'  *** WAVEWATCH III  Input pre-processing ***  '/ &
               15X,'==============================================='/)
  901 FORMAT ( '  Comment character is ''',A,''''/)
  902 FORMAT ( '  Grid name : ',A/)
!
  930 FORMAT (/'  Description of inputs'/                             &
               ' --------------------------------------------------'/ &
               '       Input type        : ',A/                       &
               '       Format type       : ',A)
 1930 FORMAT ( '          Field conserves velocity.')
 2930 FORMAT ( '          Field corrected for energy conservation.')
  931 FORMAT (/'       Single field, time: ',A)
  932 FORMAT (/'       Input grid dim.   :',I5,3X,I5)
 1932 FORMAT (/'       Opening input data file .....')
  933 FORMAT ( '       Longitude range   :',2F8.2,' (deg)'/           &
               '       Latitude range    :',2F8.2,' (deg)')
  733 FORMAT ( '       X range           :',2F8.2,' (km)'/           &
               '       Y range           :',2F8.2,' (km)')
  934 FORMAT (/'       Data type         : ',A/                       &
               '       Data record length:',I5/                       &
               '       Missing values    :',F8.2)
  935 FORMAT ( 'DT',I1 )
  938 FORMAT ( '          Icebergs included.')
  939 FORMAT ( '          Air-sea temperature differences included.')
!
  940 FORMAT (//'  Preprocessing data'/                               &
               ' --------------------------------------------------')
  941 FORMAT ( '       Interpolation factors ..... '/                 &
               '          (longitude-latitude grid)')
  942 FORMAT ( '       Interpolation factors ..... '/                 &
               '          (grid from file)')
  943 FORMAT (/'           Longitude-latitude file ',I1,' :'/         &
               '          ---------------------------------------')
  944 FORMAT ( '           Input grid dim.   :',I5,3X,I5/             &
               '           Closed longitudes :',L5)
  945 FORMAT ( '           Layout indicator  :',I5/                   &
               '           Format indicator  :',I5)
  946 FORMAT ( '           Format            : ',A)
  947 FORMAT ( '           Unit number       :',I5)
  948 FORMAT ( '           File name         : ',A)
  949 FORMAT (/'           Corresponding map file '/                  &
               '          ---------------------------------------')
!
  960 FORMAT (/'           Data file :'/                              &
               '          ---------------------------------------')
  961 FORMAT (/'           Data file :'/                              &
               '          ---------------------------------------'/   &
               '           Input grid dim.   :',I5,3X,I5)
  962 FORMAT (/'           Data file (',I1,') :'/                     &
               '          ---------------------------------------'/   &
               '           Input grid dim.   :',I5,3X,I5)
  963 FORMAT ( '           Layout indicator  :',I5)
  964 FORMAT ( '           Format indicator  :',I5)
  965 FORMAT ( '           Format for time   : ',A/                   &
               '           Format for data   : ',A)
  966 FORMAT ( '           Unit number       :',I5)
  967 FORMAT ( '           File name         : ',A)
!
  971 FORMAT (/'       Opening output data file .....')
  972 FORMAT (//'  Processing data'/                                  &
               ' --------------------------------------------------')
  973 FORMAT ( '           Time : ',A)
!/O3  974 FORMAT ( '                  reading ....')
!/O3  975 FORMAT ( '                     number of data records :',I6)
!/O3  976 FORMAT ( '                  interpolating',A,'....')
!/O3  977 FORMAT ( '                  writing ....')
!/O3  978 FORMAT ( '                  skipping ....')
!
!/O15 979 FORMAT (1X,I8.8,1X,I6.6)
!
  999 FORMAT(//'  End of program '/                                   &
               ' ========================================='/          &
               '         WAVEWATCH III Input preprocessing '/)
!
 1000 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ERROR IN OPENING INPUT FILE'/                    &
               '     IOSTAT =',I5/)
!
 1001 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     PREMATURE END OF INPUT FILE'/)
!
 1002 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ERROR IN READING FROM INPUT FILE'/               &
               '     IOSTAT =',I5/)
!
 1030 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ILLEGAL FIELD ID -->',A,'<--'/)
 1031 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ILLEGAL FORMAT ID -->',A,'<--'/)
 1032 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     THIS FORMAT TYPE IS ALLOWED FOR ICE AND LEV ONLY'/)
!
 1033 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ILLEGAL DATA RECORD LENGTH : ',I6/)
 1034 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ILLEGAL DATA TYPE : ',I2/)
!
 1035 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ILLEGAL TIME : ',I8.8,I7.6/)
 1036 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ILLEGAL SIZE OF INPUT GRID : ',I5,1X,I5/)
 1037 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ATTEMPT TO USE INPUT UNIT (',I2,                 &
               ') FOR NAMED FILE'/)
 1038 FORMAT (/' *** WAVEWATCH III WARNING IN W3PRNC : '/             &
               '     DATA READ FROM INPUT FILE')
 1039 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ARRAYS FOR INPUT FIELDS TO SMALL '/              &
               '            GRID SIZE       :',2I5/                   &
               '            ARRAY DIMENSION :',2I5/)
!
 1040 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     LONGITUDE GRID RANGE > 360 DEGR. : ',2F6.1/)
 1041 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ILLEGAL LATITUDE GRID RANGE : ',2F6.1/)
 1042 FORMAT (/' *** WAVEWATCH-III WARNING W3PRNC : '/                &
               '     GRID POINT ',2I6,2F7.2,/                         &
               ' NOT COVERED BY INPUT GRID.'/)
 1043 FORMAT (/' *** WAVEWATCH III WARNING W3PRNC : '/                &
               '     X = ',F10.1,' NOT COVERED BY INPUT GRID.'/)
 1044 FORMAT (/' *** WAVEWATCH III WARNING W3PRNC : '/                &
               '     Y = ',F10.1,' NOT COVERED BY INPUT GRID.'/)
!

!
 1045 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ERROR IN OPENING LAT-LONG DATA FILE'/            &
               '     IOSTAT =',I5/)
!
 1046 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ERROR IN OPENING MASK FILE'/                     &
               '     IOSTAT =',I5/)
!
 1051 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     CANNOT READ UNFORMATTED FROM UNIT',I3/)
!
 1060 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ERROR IN READING TIME FROM FILE (',I1,')'/       &
               '     IOSTAT =',I5/)
 1062 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ERROR IN READING NDAT FROM FILE'/                &
               '     IOSTAT =',I5/)
 1063 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ERROR IN READING DATA RECORD',I6,' FROM FILE'/   &
               '     IOSTAT =',I5/)
!
!/O15 1070 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/          &
!/O15               '     ERROR IN CREATING A TIMES FILE FOR ',A/     &
!/O15               '     IOSTAT =',I5/)
!/O15 1071 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/          &
!/O15               '     ERROR IN WRITING TIME OUTPUT ',A/           &
!/O15               '     IOSTAT =',I5/)
!
!/T 9000 FORMAT (' TEST W3PRNC : ACC : ',F6.3)
!
!/T 9040 FORMAT (' TEST W3PRNC : INPUT GRID RANGES AND INCR. AFTER CORR.'/ &
!/T              '               LON / X : ',3F10.2,                   &
!/T              ' (GLOBAL=',L1,')'/                                     &
!/T              '               LAT / Y : ',3F10.2)
!/T 9041 FORMAT (' TEST W3PRNC : INTERPOLATION DATA FOR ',A)
!/T 9042 FORMAT ('              ',I4,F8.2,2I4,2F8.2,1X,F6.3,1X,A)
!/T 9043 FORMAT (' TEST W3PRNC : GRID SHIFTED BY ',F5.0,' DEGREES / M')
!/T1 9045 FORMAT (' TEST W3PRNC : IX, IY, IXI(2), IYI(2), RD(4)')
!/T1 9046 FORMAT ('     ',2I4,2X,4I4,2X,5F6.2)
!
!/T1a 9050 FORMAT (' TEST W3PRNC : LAT-LONG OF INPUT FILE ')
!/T1a 9051 FORMAT ('             ',2I4,2F8.2,I4)
!
!/T2 9060 FORMAT (' TEST W3PRNC : INPUT FIELD (',I1,') :'/)
!/T2 9061 FORMAT (' TEST W3PRNC : INPUT DATA RECORDS :')
!/T2 9062 FORMAT ('      ',I6,' : ',6E11.3)
!/T2 9063 FORMAT ('               ',6E11.3)
!/T3 9065 FORMAT (' TEST W3PRNC : OUTPUT FIELD(S) :'/)
!/
!/ End of W3PRNC ----------------------------------------------------- /
!/
      END PROGRAM W3PRNC

!*********************************************************************


subroutine handle_err(stat)

	use netcdf
	integer, intent ( in) :: stat
	
	if(stat /= nf90_noerr) then
		print *, trim(nf90_strerror(stat))
		stop "Stopped"
	end if
end subroutine handle_err




