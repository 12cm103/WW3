#include "w3macros.h"
!/
!/ ------------------------------------------------------------------- /
!/ Macros for ESMF logging
!/
#define FILENAME "wmesmfmd.ftn"
#define CONTEXT  line=__LINE__,file=FILENAME,method=METHOD
#define PASSTHRU msg=ESMF_LOGERR_PASSTHRU,CONTEXT
!/
!/ ------------------------------------------------------------------- /
!/ Define real kind for data passed through ESMF interface
!/
#if defined(ESMF_R8)
#define ESMF_KIND_RX ESMF_KIND_R8
#define ESMF_TYPEKIND_RX ESMF_TYPEKIND_R8
#else
#define ESMF_KIND_RX ESMF_KIND_R4
#define ESMF_TYPEKIND_RX ESMF_TYPEKIND_R4
#endif
!/
!/ ------------------------------------------------------------------- /
!/ Macros for enabling test output
!/
#define TEST_WMESMFMD___disabled
#define TEST_WMESMFMD_GETIMPORT___disabled
#define TEST_WMESMFMD_SETEXPORT___disabled
#define TEST_WMESMFMD_CREATEIMPGRID___disabled 
#define TEST_WMESMFMD_CREATEEXPGRID___disabled
#define TEST_WMESMFMD_BLENDIMPFIELDS___disabled
!/
!/ ------------------------------------------------------------------- /
      module WMESMFMD
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         20-Jan-2017 |
!/                  +-----------------------------------+
!/
!/    20-Jan-2017 : Origination.                        ( version 6.02 )
!/
!/    Copyright 2009-2014 National Weather Service (NWS),
!/       National Oceanic and Atmospheric Administration.  All rights
!/       reserved.  WAVEWATCH III is a trademark of the NWS. 
!/       No unauthorized use without permission.
!/
!  1. Purpose :
!
!     National Unified Prediction Capability (NUOPC) based
!     Earth System Modeling Framework (ESMF) interface module for
!     multi-grid wave model.
!
!  2. Variables and types :
!
!     All module variables and types are scoped private by default.
!     The private module variables and types are not listed in this section.
!
!      Name      Type  Scope    Description
!     ----------------------------------------------------------------
!     ----------------------------------------------------------------
!
!  3. Subroutines and functions :
!
!     All module subroutines and functions are scoped private by default.
!
!      Name             Type   Scope    Description
!     -----------------------------------------------------------------
!      SetServices      Subr.  Public   Wave model ESMF Set Services
!     -----------------------------------------------------------------
!      InitializeP0     Subr.  Private  NUOPC/ESMF Initialize phase 0
!      InitializeP1     Subr.  Private  NUOPC/ESMF Initialize phase 1
!      InitializeP3     Subr.  Private  NUOPC/ESMF Initialize phase 3
!      Finalize         Subr.  Private  NUOPC/ESMF Finalize
!      DataInitialize   Subr.  Private  NUOPC/ESMF Data Initialize
!      ModelAdvance     Subr.  Private  NUOPC/ESMF Model Advance
!      GetImport        Subr.  Private  Get fields from import state
!      SetExport        Subr.  Private  Set fields from export state
!      CreateImpGrid    Subr.  Private  Create ESMF grid for import
!      CreateExpGrid    Subr.  Private  Create ESMF grid for export
!      BlendImpFields   Subr.  Private  Blend two import fields
!      FieldFill        Subr.  Private  Fill ESMF field
!      FieldGather      Subr.  Private  Gather ESMF field
!      FieldIndex       Func.  Private  Return field index
!      PrintTimers      Subr.  Private  Print wallclock timers
!     ----------------------------------------------------------------
!
!  4. Subroutines and functions used :
!
!     See subroutine documentation.
!
!  5. Remarks :
!
!  6. Switches :
!
!     See subroutine documentation.
!
!     !/MPI   Switch for enabling Message Passing Interface API
!     !/ST3   WAM 4+ input and dissipation.
!     !/ST4   Ardhuin et al. (2009, 2010)
!
!  7. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ Use associated modules
!/
! --- ESMF Module
      use ESMF

! --- NUOPC modules
      use NUOPC
      use NUOPC_Model, parent_SetServices => SetServices

! --- WW3 modules
      use CONSTANTS
      use WMINITMD, only: WMINIT, WMINITNML
      use WMWAVEMD, only: WMWAVE
      use WMFINLMD, only: WMFINL
      use WMMDATMD
      use W3GDATMD
      use W3IDATMD
      use W3ODATMD
      use W3WDATMD
      use W3ADATMD
      use W3TIMEMD
      use WMUPDTMD, only: WMUPD2
      use W3UPDTMD, only: W3UINI
!/ST3      use W3SRC3MD, only: W3SPR3
!/ST4      use W3SRC4MD, only: W3SPR4
!/
!/ Specify default data typing
!/
      implicit none
!/
!/ Include MPI definitions
!/
!/MPI      include "mpif.h"
!/
!/ Specify default accessibility
!/
      private
      save
!/
!/ Public module methods
!/
      public SetServices
!/
!/ Private module parameters
!/
! --- Default Mask Convention for import/export fields
      INTEGER, PARAMETER :: DEFAULT_MASK_WATER =  0
      INTEGER, PARAMETER :: DEFAULT_MASK_LAND  =  1

! --- Miscellaneous
      integer, parameter :: stdo = 6
      integer, parameter :: haloWidth = 3
      type(ESMF_VM) :: vm
      integer :: lpet, npet
      integer :: verbosity
      logical :: realizeAllExport = .false.
      integer :: maskValueWater = DEFAULT_MASK_WATER
      integer :: maskValueLand  = DEFAULT_MASK_LAND
      character(ESMF_MAXSTR) :: msg
      real(ESMF_KIND_RX) :: zeroValue
      real(ESMF_KIND_RX) :: missingValue
!
! --- Timing
      integer, parameter :: numwt=8
      character(32) :: wtnam(numwt)
      integer       :: wtcnt(numwt)
      real(8)       :: wtime(numwt)
!
! --- Import fields
      type(ESMF_ArraySpec)  :: impArraySpec2D
      type(ESMF_StaggerLoc) :: impStaggerLoc
      type(ESMF_Index_Flag) :: impIndexFlag
      type(ESMF_Grid)       :: impGrid
      integer               :: impGridID
      logical               :: impGridIsLocal
      integer               :: impHaloLWidth(2)
      integer               :: impHaloUWidth(2)
      type(ESMF_RouteHandle):: impHaloRH
      type(ESMF_Field)      :: impMask
      logical               :: noActiveImpFields
      integer, parameter    :: numImpFields = 6
      character(6)          :: impFieldName(numImpFields)
      character(128)        :: impFieldStdName(numImpFields)
      integer               :: impFieldDim(numImpFields)
      logical               :: initRqrdImpField(numImpFields)
      logical               :: isActiveImpField(numImpFields)
      logical               :: isVectorImpField(numImpFields)
      type(ESMF_Field)      :: impField(numImpFields)
!
! --- Background import fields
      character(10)         :: mbgFieldName(numImpFields)
      character(128)        :: mbgFieldStdName(numImpFields)
      logical               :: isActiveMbgField(numImpFields)
      type(ESMF_Field)      :: mbgField(numImpFields)
!
! --- Export fields
      type(ESMF_ArraySpec)  :: expArraySpec2D
      type(ESMF_ArraySpec)  :: expArraySpec3D
      type(ESMF_StaggerLoc) :: expStaggerLoc
      type(ESMF_Index_Flag) :: expIndexFlag
      type(ESMF_Grid)       :: expGrid
      integer               :: expGridID
      logical               :: expGridIsLocal
      integer               :: expHaloLWidth(2)
      integer               :: expHaloUWidth(2)
      type(ESMF_RouteHandle):: expHaloRH
      type(ESMF_Field)      :: expMask
      logical               :: include3D
      integer               :: nz ! Number of z-levels for 3D fields
      logical               :: noActiveExpFields
      integer, parameter    :: numExpFields = 2
      character(6)          :: expFieldName(numExpFields)
      character(128)        :: expFieldStdName(numExpFields)
      integer               :: expFieldDim(numExpFields)
      logical               :: isActiveExpField(numExpFields)
      logical               :: isVectorExpField(numExpFields)
      type(ESMF_Field)      :: expField(numExpFields)
!
! --- Native field stuff
      type(ESMF_ArraySpec)  :: natArraySpec1D
      type(ESMF_StaggerLoc) :: natStaggerLoc
      type(ESMF_Index_Flag) :: natIndexFlag
      type(ESMF_Grid)       :: natGrid
      integer               :: natGridID
      logical               :: natGridIsLocal
      type(ESMF_RouteHandle):: n2eRH
!/
!/ ------------------------------------------------------------------- /
      contains
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "SetServices"
      subroutine SetServices ( gcomp, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         20-Jan-2017 |
!/                  +-----------------------------------+
!/
!/    20-Jan-2017 : Origination.                        ( version 6.02 )
!/
!  1. Purpose :
!
!     Wave model ESMF set services.
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp   Type   I/O Gridded component
!       rc      Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name            Type   Module    Description
!     ----------------------------------------------------------------
!      InitializeP0    Subr.  WMESMFMD  Wave model NUOPC/ESMF Initialize phase 0
!      InitializeP1    Subr.  WMESMFMD  Wave model NUOPC/ESMF Initialize phase 1
!      InitializeP3    Subr.  WMESMFMD  Wave model NUOPC/ESMF Initialize phase 3
!      Finalize        Subr.  WMESMFMD  Wave model NUOPC/ESMF Finalize
!      DataInitialize  Subr.  WMESMFMD  Wave model NUOPC/ESMF Data Initialize
!      ModelAdvance    Subr.  WMESMFMD  Wave model NUOPC/ESMF Model Advance
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      !NONE
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_SUCCESS

! --- Initialize wallclock timers

      wtnam( 1) = 'InitializeP0'
      wtnam( 2) = 'InitializeP1'
      wtnam( 3) = 'InitializeP3'
      wtnam( 4) = 'DataInitialize'
      wtnam( 5) = 'ModelAdvance'
      wtnam( 6) = 'Finalize'
      wtnam( 7) = 'GetImport'
      wtnam( 8) = 'SetExport'
      wtcnt( :) = 0
      wtime( :) = 0d0
!
! -------------------------------------------------------------------- /
! 1.  NUOPC model component will register the generic methods
!
      call NUOPC_CompDerive(gcomp, parent_SetServices, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! 2.  Set model entry points
!
! --- Initialize - phase 0 (requires use of ESMF method)

      call ESMF_GridCompSetEntryPoint(gcomp, ESMF_METHOD_INITIALIZE, &
        userRoutine=InitializeP0, phase=0, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return

! --- Set entry points for initialize methods

      ! >= IPDv03 supports satisfying inter-model data dependencies and
      ! the transfer of ESMF Grid & Mesh objects between Model and/or
      ! Mediator components during initialization
      ! IPDv03p1: advertise import & export fields
      call NUOPC_CompSetEntryPoint(gcomp, ESMF_METHOD_INITIALIZE, &
        phaseLabelList=(/"IPDv03p1"/), userRoutine=InitializeP1, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      ! IPDv03p2: unspecified by NUOPC -- not required
      ! IPDv03p3: realize import & export fields
      call NUOPC_CompSetEntryPoint(gcomp, ESMF_METHOD_INITIALIZE, &
        phaseLabelList=(/"IPDv03p3"/), userRoutine=InitializeP3, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      ! IPDv03p4: relevant for TransferActionGeomObject=="accept"
      ! IPDv03p5: relevant for TransferActionGeomObject=="accept"
      ! IPDv03p6: check compatibility of fields connected status
      ! IPDv03p7: handle field data initialization

!
! -------------------------------------------------------------------- /
! 3.  Register specializing methods
!
! --- Model initialize export data method

      call NUOPC_CompSpecialize(gcomp, specLabel=label_DataInitialize, &
        specRoutine=DataInitialize, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return

! --- Model checkImport method (overriding default)

      call ESMF_MethodRemove(gcomp, label_CheckImport, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call NUOPC_CompSpecialize(gcomp, specLabel=label_CheckImport, &
        specRoutine=NUOPC_NoOp, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      
! --- Model advance method

      call NUOPC_CompSpecialize(gcomp, specLabel=label_Advance, &
        specRoutine=ModelAdvance, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return

! --- Model finalize method

      call NUOPC_CompSpecialize(gcomp, specLabel=label_Finalize, &
        specRoutine=Finalize, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! Post
!
      rc = ESMF_SUCCESS
!/
!/ End of SetServices ------------------------------------------------ /
!/
      end subroutine SetServices
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "InitializeP0"
      subroutine InitializeP0 ( gcomp, impState, expState, extClock, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         20-Jan-2017 |
!/                  +-----------------------------------+
!/
!/    20-Jan-2017 : Origination.                        ( version 6.02 )
!/
!  1. Purpose :
!
!     Initialize wave model (phase 0)
!     * Define the NUOPC Initialize Phase Mapping
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp     Type   I/O Gridded component
!       impState  Type   I/O Import state
!       expState  Type   I/O Export state
!       extClock  Type   I   External clock
!       rc        Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      NONE
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      type(ESMF_State)    :: impState
      type(ESMF_State)    :: expState
      type(ESMF_Clock)    :: extClock
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(ESMF_MAXSTR) :: cname
      character(ESMF_MAXSTR) :: valueString
      integer, parameter :: iwt=1
      real(8) :: wstime, wftime
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_SUCCESS
      call ESMF_VMWtime(wstime)
      call ESMF_GridCompGet(gcomp, name=cname, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! Determine verbosity
!
      call NUOPC_CompAttributeGet(gcomp, name='Verbosity', &
        value=valueString, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      verbosity = ESMF_UtilString2Int( valueString, &
        specialStringList=(/'high','max '/), &
        specialValueList=(/    255,   255/), rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return

      if (verbosity.gt.0) call ESMF_LogWrite(trim(cname)// &
        ': entered InitializeP0', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! Define initialization phases
! * switch to IPDv03 by filtering all other phaseMap entries
!
      call NUOPC_CompFilterPhaseMap(gcomp, ESMF_METHOD_INITIALIZE, &
        acceptStringList=(/"IPDv03p"/), rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! Post
!
      rc = ESMF_SUCCESS
      call ESMF_VMWtime(wftime)
      wtime(iwt) = wtime(iwt) + wftime - wstime
      wtcnt(iwt) = wtcnt(iwt) + 1
      if (verbosity.gt.0) call ESMF_LogWrite(trim(cname)// &
        ': leaving InitializeP0', ESMF_LOGMSG_INFO)
!/
!/ End of InitializeP0 ----------------------------------------------- /
!/
      end subroutine InitializeP0
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "InitializeP1"
      subroutine InitializeP1 ( gcomp, impState, expState, extClock, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         20-Jan-2017 |
!/                  +-----------------------------------+
!/
!/    20-Jan-2017 : Origination.                        ( version 6.02 )
!/
!  1. Purpose :
!
!     Initialize wave model (phase 1)
!     * Advertise fields in import and export states.
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp     Type   I/O Gridded component
!       impState  Type   I/O Import state
!       expState  Type   I/O Export state
!       extClock  Type   I   External clock
!       rc        Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name            Type  Module   Description
!     ----------------------------------------------------------------
!      WMINIT          Subr. WMINITMD Wave model initialization
!      WMINITNML       Subr. WMINITMD Wave model initialization
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!     ----------------------------------------------------------------
!      1.  Initialization necessary for driver
!        a General I/O: (implicit in WMMDATMD)
!        b MPI environment
!        c Identifying output to "screen" unit
!      2.  Initialization of all wave models / grids
!      3.  Advertise import fields
!      4.  Advertise export fields
!     ----------------------------------------------------------------
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      type(ESMF_State)    :: impState
      type(ESMF_State)    :: expState
      type(ESMF_Clock)    :: extClock
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(ESMF_MAXSTR) :: cname
      integer, parameter :: iwt=2
      real(8) :: wstime, wftime
      integer :: idsi, idso, idss, idst, idse
      integer :: mpiComm = -99
      logical :: configIsPresent
      type(ESMF_Config) :: config
      character(ESMF_MAXSTR) :: wrkdir = '.'
      character(ESMF_MAXSTR) :: preamb = '.'
      character(ESMF_MAXSTR) :: ifname = 'ww3_multi.inp'
      logical :: lsep_ss = .false.
      logical :: lsep_st = .false.
      logical :: lsep_se = .false.
      character(ESMF_MAXSTR) :: attstr
      integer(ESMF_KIND_I4) :: yy,mm,dd,h,m,s
      type(ESMF_Time) :: ttmp
      type(ESMF_TimeInterval) :: tstep, etstep
      integer :: i1, i2, i3, i, j, n, imod, jmod
      integer, allocatable :: cplmap(:,:)
      logical :: includeObg, includeAbg, includeIbg
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_SUCCESS
      call ESMF_VMWtime(wstime)
      call ESMF_GridCompGet(gcomp, name=cname, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (verbosity.gt.0) call ESMF_LogWrite(trim(cname)// &
        ': entered InitializeP1', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! 1.  Initialization necessary for driver
!
! 1.a Set global flag indicating that model is an ESMF Component
!
      is_esmf_component = .true.
      zeroValue = real(0,ESMF_KIND_RX)
      missingValue = real(0,ESMF_KIND_RX)
!
!
! 1.b Get MPI environment from ESMF VM and set WW3 MPI related variables
!
      call ESMF_GridCompGet(gcomp, vm=vm, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_VMGet(vm, petCount=npet, localPet=lpet, &
        mpiCommunicator=mpiComm, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      nmproc = npet
      improc = lpet + 1
      nmpscr = 1
      if ( improc .eq. nmpscr ) write (*,900)
!
! 1.c Get background model info
!
#if defined(COAMPS)
      call ESMF_AttributeGet(gcomp, name="OcnBackground", &
        value=attstr, defaultValue="none", &
        convention="COAMPS", purpose="General", rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      includeObg = trim(attstr).eq."model"
      call ESMF_AttributeGet(gcomp, name="AtmBackground", &
        value=attstr, defaultValue="none", &
        convention="COAMPS", purpose="General", rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      includeAbg = trim(attstr).eq."model"
      call ESMF_AttributeGet(gcomp, name="IceBackground", &
        value=attstr, defaultValue="none", &
        convention="COAMPS", purpose="General", rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      includeIbg = trim(attstr).eq."model"
      call ESMF_AttributeGet(gcomp, name="MissingValue", &
        value=missingValue, defaultValue=real(0,ESMF_KIND_RX), &
        convention="COAMPS", purpose="General", rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
#else
      includeObg = .false.
      includeAbg = .false.
      includeIbg = .false.
#endif
!
! 1.d Config input
!
      call ESMF_GridCompGet(gcomp, configIsPresent=configIsPresent, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (configIsPresent) then
        call ESMF_GridCompGet(gcomp, config=config, rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        ! working directory
        call ESMF_ConfigGetAttribute(config, wrkdir, &
          label=trim(cname)//'_work_dir:', default='.', rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        ! I/O options
        call ESMF_ConfigGetAttribute(config, ifname, &
          label=trim(cname)//'_input_file_name:', &
          default='ww3_multi.inp', rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call ESMF_ConfigGetAttribute(config, lsep_ss, &
          label=trim(cname)//'_stdo_output_to_file:', default=.false., rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call ESMF_ConfigGetAttribute(config, lsep_st, &
          label=trim(cname)//'_test_output_to_file:', default=.false., rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call ESMF_ConfigGetAttribute(config, lsep_se, &
          label=trim(cname)//'_error_output_to_file:', default=.false., rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        ! realize all export flag
        call ESMF_ConfigGetAttribute(config, realizeAllExport, &
          label=trim(cname)//'_realize_all_export:', default=.false., rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        ! grid mask convention
        call ESMF_ConfigGetAttribute(config, maskValueWater, &
          label='mask_value_water:', default=DEFAULT_MASK_WATER, rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call ESMF_ConfigGetAttribute(config, maskValueLand, &
          label='mask_value_land:', default=DEFAULT_MASK_LAND, rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      endif
!     preamb = trim(wrkdir)//'/'
      preamb = trim(preamb)//'/' !TODO: have separate paths for .inp, logs and data?
!
! 1.e Set internal start/stop time from external start/stop time
!
      call ESMF_ClockGet(extClock, startTime=ttmp, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_TimeGet(ttmp, yy=yy,mm=mm,dd=dd,h=h,m=m,s=s, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      stime(1) = 10000*yy + 100*mm + dd
      stime(2) = 10000*h  + 100*m  + s

      call ESMF_ClockGet(extClock, stopTime=ttmp, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_TimeGet(ttmp, yy=yy,mm=mm,dd=dd,h=h,m=m,s=s, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      etime(1) = 10000*yy + 100*mm + dd
      etime(2) = 10000*h  + 100*m  + s
!
! 1.f Identify available unit numbers
! Each ESMF_UtilIOUnitGet is followed by an OPEN statement for that
! unit so that subsequent ESMF_UtilIOUnitGet calls do not return the
! the same unit.  After getting all the available unit numbers, close
! the units since they will be opened within WMINIT.
!
      call ESMF_UtilIOUnitGet(idsi); open(unit=idsi, status='scratch');
      call ESMF_UtilIOUnitGet(idso); open(unit=idso, status='scratch');
      call ESMF_UtilIOUnitGet(idss); open(unit=idss, status='scratch');
      call ESMF_UtilIOUnitGet(idst); open(unit=idst, status='scratch');
      call ESMF_UtilIOUnitGet(idse); open(unit=idse, status='scratch');
      close(idsi); close(idso); close(idss); close(idst); close(idse);
!
! -------------------------------------------------------------------- /
! 2.  Initialization of all wave models / grids
!
! 2.a Call into WMINIT
!     
      if ( .not.lsep_ss ) idss = stdo
      if ( .not.lsep_st ) idst = stdo
      if ( .not.lsep_se ) idse = stdo
      if ( trim(ifname).eq.'ww3_multi.nml' ) then
        call wminitnml ( idsi, idso, idss, idst, idse, trim(ifname), &
                         mpicomm, preamb=preamb )
      else
        call wminit ( idsi, idso, idss, idst, idse, trim(ifname), &
                      mpicomm, preamb=preamb )
      endif
!
! 2.b Check consistency between internal timestep and external
!     timestep (coupling interval)
!
      call ESMF_ClockGet(extClock, timeStep=etstep, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 2.c Trap unsupported CPL input forcing settings
!
      if ( any(inpmap.lt.0) ) then
        if ( nrgrd.gt.1 ) then
          if ( any(inpmap.eq.-999) ) then
            write (msg,'(a)') 'CPL input forcing defined on a '// &
              'native grid is not supported with multiple model grids'
            if ( improc .eq. nmpscr ) write (idse,'(a)') trim(msg)
            call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_ERROR)
            rc = ESMF_FAILURE
            return
          endif
        endif
        allocate (cplmap(nrgrd,jfirst:8), stat=rc)
        if (ESMF_LogFoundAllocError(rc, PASSTHRU)) return
        jmod = minval(inpmap)
        cplmap = inpmap
        where ( inpmap.lt.0 ) cplmap = jmod
        if ( any(inpmap.ne.cplmap) ) then
          write (msg,'(a)') 'All CPL input forcing must be '// &
            'defined on the same grid'
          if ( improc .eq. nmpscr ) write (idse,'(a)') trim(msg)
          call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_ERROR)
          rc = ESMF_FAILURE
          return
        endif
        deallocate (cplmap, stat=rc)
        if (ESMF_LogFoundDeallocError(rc, PASSTHRU)) return
      endif
!
! -------------------------------------------------------------------- /
! 3.  Initialize import field list
!
      isActiveImpField(:) = .false.
      impFieldDim(:) = 2

      j = 1;  i1 = 1;  i2 = 1;
      isActiveImpField(i1:i2) = any(inpmap(:,j).lt.0)
      impFieldName(i1)        = 'seahgt'
      impFieldStdName(i1)     = 'sea_surface_height_above_sea_level'
      initRqrdImpField(i1:i2) = .true.
      isActiveMbgField(i1:i2) = isActiveImpField(i1).and.includeObg

      j = 2;  i1 = 2;  i2 = 3;
      isActiveImpField(i1:i2) = any(inpmap(:,j).lt.0)
      impFieldName(i1)        = 'uucurr'
      impFieldStdName(i1)     = 'surface_eastward_sea_water_velocity'
      impFieldName(i2)        = 'vvcurr'
      impFieldStdName(i2)     = 'surface_northward_sea_water_velocity'
      initRqrdImpField(i1:i2) = .true.
      isActiveMbgField(i1:i2) = isActiveImpField(i1).and.includeObg

      j = 3;  i1 = 4;  i2 = 5;
      isActiveImpField(i1:i2) = any(inpmap(:,j).lt.0)
      impFieldName(i1)        = 'uutrue'
      impFieldStdName(i1)     = 'eastward_wind_at_10m_height'
      impFieldName(i2)        = 'vvtrue'
      impFieldStdName(i2)     = 'northward_wind_at_10m_height'
      initRqrdImpField(i1:i2) = .true.
      isActiveMbgField(i1:i2) = isActiveImpField(i1).and.includeAbg

      j = 4;  i1 = 6;  i2 = 6;
      isActiveImpField(i1:i2) = any(inpmap(:,j).lt.0)
      impFieldName(i1)        = 'seaice'
      impFieldStdName(i1)     = 'sea_ice_concentration'
      initRqrdImpField(i1:i2) = .true.
      isActiveMbgField(i1:i2) = isActiveImpField(i1).and.includeIbg

      do i = 1,numImpFields
        mbgFieldName(i) = 'mbg_'//trim(impFieldName(i))
        mbgFieldStdName(i) = 'mbg_'//trim(impFieldStdName(i))
      enddo

      noActiveImpFields = all(.not.isActiveImpField)
!
! -------------------------------------------------------------------- /
! 4.  Initialize export field list
!
      isActiveExpField(:) = .false.

      i1 = 1;  i2 = 1;  i3 = 1;
      expFieldName(i1)    = 'charno'
      expFieldStdName(i1) = 'wave_induced_charnock_parameter'
      expFieldDim(i1)     = 2

      i1 = 2;  i2 = 2;  i3 = 2;
      expFieldName(i1)    = 'z0rlen'
      expFieldStdName(i1) = 'wave_z0_roughness_length'
      expFieldDim(i1)     = 2

!     i1 = 2;  i2 = 3;  i3 = 3;
!     expFieldName(i1)    = 'uscurr'
!     expFieldStdName(i1) = 'eastward_stokes_drift_current'
!     expFieldDim(i1)     = 3
!     expFieldName(i2)    = 'vscurr'
!     expFieldStdName(i2) = 'northward_stokes_drift_current'
!     expFieldDim(i2)     = 3

!     i1 = 4;  i2 = 5;  i3 = 6;
!     expFieldName(i1)    = 'wbcuru'
!     expFieldStdName(i1) = 'eastward_wave_bottom_current'
!     expFieldDim(i1)     = 2
!     expFieldName(i2)    = 'wbcurv'
!     expFieldStdName(i2) = 'northward_wave_bottom_current'
!     expFieldDim(i2)     = 2
!     expFieldName(i3)    = 'wbcurf'
!     expFieldStdName(i3) = 'wave_bottom_current_radian_frequency'
!     expFieldDim(i3)     = 2

      noActiveExpFields = all(.not.isActiveExpField)
!
! -------------------------------------------------------------------- /
! 5.  Advertise import fields
!
! 5.a Advertise active import fields
!
      n = 0
      do i = 1,numImpFields
        if (.not.isActiveImpField(i)) cycle
        n = n + 1
        call NUOPC_Advertise(impState, &
          trim(impFieldStdName(i)), name=trim(impFieldName(i)), rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        if (.not.isActiveMbgField(i)) cycle
        n = n + 1
        call NUOPC_Advertise(impState, &
          trim(mbgFieldStdName(i)), name=trim(mbgFieldName(i)), rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      enddo
!
! 5.b Report advertised import fields
!
      write(msg,'(a,i0,a)') trim(cname)// &
        ': List of advertised import fields(',n,'):'
      call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      write(msg,'(a,a5,a,a10,a3,a)') trim(cname)// &
        ': ','index',' ','name',' ','standardName'
      call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      n = 0
      do i = 1,numImpFields
        if (.not.isActiveImpField(i)) cycle
        n = n + 1
        write(msg,'(a,i5,a,a10,a3,a)') trim(cname)//': ',n, &
          ' ',trim(impFieldName(i)),' ',trim(impFieldStdName(i))
        call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
        if (.not.isActiveMbgField(i)) cycle
        n = n + 1
        write(msg,'(a,i5,a,a10,a3,a)') trim(cname)//': ',n, &
          ' ',trim(mbgFieldName(i)),' ',trim(mbgFieldStdName(i))
        call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      enddo
!
! -------------------------------------------------------------------- /
! 6.  Advertise export fields
!
! 6.a Advertise all export fields
!
      do i = 1,numExpFields
        call NUOPC_Advertise(expState, &
          trim(expFieldStdName(i)), name=trim(expFieldName(i)), rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      enddo
!
! 6.b Report advertised export fields
!
      write(msg,'(a,i0,a)') trim(cname)// &
        ': List of advertised export fields(',numExpFields,'):'
      call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      write(msg,'(a,a5,a,a10,a3,a)') trim(cname)// &
        ': ','index',' ','name',' ','standardName'
      call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      do i = 1,numExpFields
        write(msg,'(a,i5,a,a10,a3,a)') trim(cname)//': ',i, &
          ' ',trim(expFieldName(i)),' ',trim(expFieldStdName(i))
        call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      enddo
!
! -------------------------------------------------------------------- /
! Post
!
      rc = ESMF_SUCCESS
      call ESMF_VMWtime(wftime)
      wtime(iwt) = wtime(iwt) + wftime - wstime
      wtcnt(iwt) = wtcnt(iwt) + 1
      if (verbosity.gt.0) call ESMF_LogWrite(trim(cname)// &
        ': leaving InitializeP1', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! Formats
!
  900 format (/15x,'     *** WAVEWATCH III Multi-grid shell ***    '/ &
               15x,'================================================='/)
!/
!/ End of InitializeP1 ----------------------------------------------- /
!/
      end subroutine InitializeP1
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "InitializeP3"
      subroutine InitializeP3 ( gcomp, impState, expState, extClock, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         20-Jan-2017 |
!/                  +-----------------------------------+
!/
!/    20-Jan-2017 : Origination.                        ( version 6.02 )
!/
!  1. Purpose :
!
!     Initialize wave model (phase 3)
!     * Realize fields in import and export states.
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp     Type   I/O Gridded component
!       impState  Type   I/O Import state
!       expState  Type   I/O Export state
!       extClock  Type   I   External clock
!       rc        Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name            Type  Module   Description
!     ----------------------------------------------------------------
!      WMINIT          Subr. WMINITMD Wave model initialization
!      WMINITNML       Subr. WMINITMD Wave model initialization
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      type(ESMF_State)    :: impState
      type(ESMF_State)    :: expState
      type(ESMF_Clock)    :: extClock
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(ESMF_MAXSTR) :: cname
      integer, parameter :: iwt=3
      real(8) :: wstime, wftime
      integer :: i, n
      logical :: isConnected
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_SUCCESS
      call ESMF_VMWtime(wstime)
      call ESMF_GridCompGet(gcomp, name=cname, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (verbosity.gt.0) call ESMF_LogWrite(trim(cname)// &
        ': entered InitializeP3', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! 1.  Realize active import fields
!
! 1.a Create ESMF grid for import fields
!
      call CreateImpGrid( gcomp, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 1.b Create import fields and realize
!
      n = 0
      do i = 1,numImpFields
        if (.not.isActiveImpField(i)) cycle
        n = n + 1
        impField(i) = ESMF_FieldCreate( impGrid, impArraySpec2D, &
          totalLWidth=impHaloLWidth, totalUWidth=impHaloUWidth, &
          staggerLoc=impStaggerLoc, indexFlag=impIndexFlag, &
          name=trim(impFieldName(i)), rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call FieldFill( impField(i), zeroValue, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call NUOPC_Realize( impState, impField(i), rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        if (.not.isActiveMbgField(i)) cycle
        n = n + 1
        mbgField(i) = ESMF_FieldCreate( impGrid, impArraySpec2D, &
          totalLWidth=impHaloLWidth, totalUWidth=impHaloUWidth, &
          staggerLoc=impStaggerLoc, indexFlag=impIndexFlag, &
          name=trim(mbgFieldName(i)), rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call FieldFill( mbgField(i), zeroValue, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call NUOPC_Realize( impState, mbgField(i), rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      enddo
!
! 1.c Report realized import fields
!
      write(msg,'(a,i0,a)') trim(cname)// &
        ': List of realized import fields(',n,'):'
      call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      write(msg,'(a,a5,a,a10,a3,a)') trim(cname)// &
        ': ','index',' ','name',' ','standardName'
      call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      n = 0
      do i = 1,numImpFields
        if (.not.isActiveImpField(i)) cycle
        n = n + 1
        write(msg,'(a,i5,a,a10,a3,a)') trim(cname)//': ',n, &
          ' ',trim(impFieldName(i)),' ',trim(impFieldStdName(i))
        call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
        if (.not.isActiveMbgField(i)) cycle
        n = n + 1
        write(msg,'(a,i5,a,a10,a3,a)') trim(cname)//': ',n, &
          ' ',trim(mbgFieldName(i)),' ',trim(mbgFieldStdName(i))
        call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      enddo
!
! -------------------------------------------------------------------- /
! 2.  Realize active export fields
!
! 2.a Set connected export fields as active and remove unconnected
!     If realizeAllExport, then set all fields as active and realize.
!
      do i = 1,numExpFields
        isConnected = NUOPC_IsConnected(expState, &
                      expFieldName(i), rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        isActiveExpField(i) = isConnected .or. realizeAllExport
        if (isActiveExpField(i)) noActiveExpFields = .false.
        if (.not.isActiveExpField(i)) then
          call ESMF_StateRemove(expState, (/expFieldName(i)/), rc=rc)
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
        endif
      enddo
!
! 2.b Create ESMF grid for export fields
!
      call CreateExpGrid( gcomp, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 2.c Create active export fields and realize
!
      n = 0
      do i = 1,numExpFields
        if (.not.isActiveExpField(i)) cycle
        n = n + 1
        if ( expFieldDim(i).eq.3 ) then
          expField(i) = ESMF_FieldCreate( expGrid, expArraySpec3D, &
            totalLWidth=expHaloLWidth, totalUWidth=expHaloUWidth, &
            staggerLoc=expStaggerLoc, name=trim(expFieldName(i)), rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
        else
          expField(i) = ESMF_FieldCreate( expGrid, expArraySpec2D, &
            totalLWidth=expHaloLWidth, totalUWidth=expHaloUWidth, &
            staggerLoc=expStaggerLoc, name=trim(expFieldName(i)), rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
        endif
        call FieldFill( expField(i), zeroValue, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call NUOPC_Realize( expState, expField(i), rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      enddo
!
! 2.d Report realized export fields
!
      write(msg,'(a,i0,a)') trim(cname)// &
        ': List of realized export fields(',n,'):'
      call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      write(msg,'(a,a5,a,a10,a3,a)') trim(cname)// &
        ': ','index',' ','name',' ','standardName'
      call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      n = 0
      do i = 1,numExpFields
        if (.not.isActiveExpField(i)) cycle
        n = n + 1
        write(msg,'(a,i5,a,a10,a3,a)') trim(cname)//': ',n, &
          ' ',trim(expFieldName(i)),' ',trim(expFieldStdName(i))
        call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      enddo
!
! -------------------------------------------------------------------- /
! Post
!
      rc = ESMF_SUCCESS
      call ESMF_VMWtime(wftime)
      wtime(iwt) = wtime(iwt) + wftime - wstime
      wtcnt(iwt) = wtcnt(iwt) + 1
      if (verbosity.gt.0) call ESMF_LogWrite(trim(cname)// &
        ': leaving InitializeP3', ESMF_LOGMSG_INFO)
!/
!/ End of InitializeP3 ----------------------------------------------- /
!/
      end subroutine InitializeP3
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "Finalize"
      subroutine Finalize ( gcomp, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         20-Jan-2017 |
!/                  +-----------------------------------+
!/
!/    20-Jan-2017 : Origination.                        ( version 6.02 )
!/
!  1. Purpose :
!
!     Finalize wave model
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp     Type   I/O Gridded component
!       rc        Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      WMFINL    Subr. WMFINLMD Wave model finalization
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(ESMF_MAXSTR) :: cname
      integer, parameter :: iwt=6
      real(8) :: wstime, wftime
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_SUCCESS
      call ESMF_VMWtime(wstime)
      call ESMF_GridCompGet(gcomp, name=cname, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (verbosity.gt.0) call ESMF_LogWrite(trim(cname)// &
        ': entered Finalize', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! 1.  Finalize the wave model
!
      call wmfinl
!
! -------------------------------------------------------------------- /
! 2.  Clean up ESMF data structures
!
!TODO
!
! -------------------------------------------------------------------- /
! Post
!
      call ESMF_VMWtime(wftime)
      wtime(iwt) = wtime(iwt) + wftime - wstime
      wtcnt(iwt) = wtcnt(iwt) + 1
      call PrintTimers(trim(cname), wtnam, wtcnt, wtime)
      rc = ESMF_SUCCESS
      if ( improc .eq. nmpscr ) write (*,999)
      if (verbosity.gt.0) call ESMF_LogWrite(trim(cname)// &
        ': leaving Finalize', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! Formats
!
  999 format(//'  End of program '/                                   &
               ' ========================================'/           &
               '          WAVEWATCH III Multi-grid shell '/)
!/
!/ End of Finalize --------------------------------------------------- /
!/
      end subroutine Finalize
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "DataInitialize"
      subroutine DataInitialize ( gcomp, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         20-Jan-2017 |
!/                  +-----------------------------------+
!/
!/    20-Jan-2017 : Origination.                        ( version 6.02 )
!/
!  1. Purpose :
!
!     Initialize wave model export data
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp     Type   I/O Gridded component
!       rc        Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name            Type  Module   Description
!     ----------------------------------------------------------------
!      GetImport       Subr. WMESMFMD Wave model get import fields
!      SetExport       Subr. WMESMFMD Wave model set export fields
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(ESMF_MAXSTR) :: cname
      integer, parameter :: iwt=4
      real(8) :: wstime, wftime
      type(ESMF_Clock) :: clock
      type(ESMF_Time) :: currTime
      logical :: fldUpdated, allUpdated
      integer :: i, imod
      logical :: local
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_SUCCESS
      call ESMF_VMWtime(wstime)
      call ESMF_GridCompGet(gcomp, name=cname, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (verbosity.gt.0) call ESMF_LogWrite(trim(cname)// &
        ': entered DataInitialize', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! 1.  Check that required import fields show correct time stamp
!
      call ESMF_GridCompGet(gcomp, clock=clock, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_ClockGet(clock, currTime=currTime, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return

      allUpdated = .true.
      do i = 1,numImpFields
        if (.not.isActiveImpField(i)) cycle
        if (initRqrdImpField(i)) then
          fldUpdated = NUOPC_IsAtTime(impField(i), currTime, rc=rc)
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
          if (fldUpdated) then
            write(msg,'(a,a10,a,a13)') trim(cname)//': ', &
              trim(impFieldName(i)),': inter-model data dependency: ', &
              'SATISFIED'
          else
            allUpdated = .false.
            write(msg,'(a,a10,a,a13)') trim(cname)//': ', &
              trim(impFieldName(i)),': inter-model data dependency: ', &
              'NOT SATISFIED'
          endif
        else
          write(msg,'(a,a10,a,a13)') trim(cname)//': ', &
            trim(impFieldName(i)),': inter-model data dependency: ', &
            'NOT  REQUIRED'
        endif
        if (verbosity.gt.0) call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
        if (improc.eq.nmpscr) write(*,'(a)') trim(msg)
        ! background
        if (.not.isActiveMbgField(i)) cycle
        if (initRqrdImpField(i)) then
          fldUpdated = NUOPC_IsAtTime(mbgField(i), currTime, rc=rc)
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
          if (fldUpdated) then
            write(msg,'(a,a10,a,a13)') trim(cname)//': ', &
              trim(mbgFieldName(i)),': inter-model data dependency: ', &
              'SATISFIED'
          else
            allUpdated = .false.
            write(msg,'(a,a10,a,a13)') trim(cname)//': ', &
              trim(mbgFieldName(i)),': inter-model data dependency: ', &
              'NOT SATISFIED'
          endif
        else
          write(msg,'(a,a10,a,a13)') trim(cname)//': ', &
            trim(mbgFieldName(i)),': inter-model data dependency: ', &
            'NOT  REQUIRED'
        endif
        if (verbosity.gt.0) call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
        if (improc.eq.nmpscr) write(*,'(a)') trim(msg)
      enddo
!
! If not all import dependencies are satisfied, then return
!
      if (.not.allUpdated) goto 1
!
! -------------------------------------------------------------------- /
! 2.  All import dependencies are satisfied, so finish initialization
!
! 2.a Report all import dependencies are satisfied
!
      write(msg,'(a)') trim(cname)// &
        ': all inter-model data dependencies SATISFIED'
      if (verbosity.gt.0) call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      if (improc.eq.nmpscr) write(*,'(a)') trim(msg)
!
! 2.b Get import fields
!
      call GetImport(gcomp, rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 2.d Finish initialization (compute initial state), if not restart
!
      do imod = 1,nrgrd
        call w3setg ( imod, mdse, mdst )
        call w3setw ( imod, mdse, mdst )
        call w3seta ( imod, mdse, mdst )
        call w3seti ( imod, mdse, mdst )
        call w3seto ( imod, mdse, mdst )
        call wmsetm ( imod, mdse, mdst )
        local = iaproc .gt. 0 .and. iaproc .le. naproc
        if ( local .and. flcold .and. fliwnd ) call w3uini( va )
      enddo
!
! 2.e Set export fields
!
      call SetExport(gcomp, rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 2.f Set Updated Field Attribute to "true", indicating to the
!     generic code to set the timestamp for these fields
!
      do i = 1,numExpFields
        if (.not.isActiveExpField(i)) cycle
        call NUOPC_SetAttribute(expField(i), name="Updated", &
          value="true", rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      enddo
!
! 2.g Set InitializeDataComplete Attribute to "true", indicating to the
!     generic code that all inter-model data dependencies are satisfied
!
      call NUOPC_CompAttributeSet(gcomp, name="InitializeDataComplete", &
        value="true", rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! Post
!
1     rc = ESMF_SUCCESS
      call ESMF_VMWtime(wftime)
      wtime(iwt) = wtime(iwt) + wftime - wstime
      wtcnt(iwt) = wtcnt(iwt) + 1
      if (verbosity.gt.0) call ESMF_LogWrite(trim(cname)// &
        ': leaving DataInitialize', ESMF_LOGMSG_INFO)
!/
!/ End of DataInitialize --------------------------------------------- /
!/
      end subroutine DataInitialize
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "ModelAdvance"
      subroutine ModelAdvance ( gcomp, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         20-Jan-2017 |
!/                  +-----------------------------------+
!/
!/    20-Jan-2017 : Origination.                        ( version 6.02 )
!/
!  1. Purpose :
!
!     Advance wave model in time
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp     Type   I/O Gridded component
!       rc        Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      GetImport Subr. WMESMFMD Wave model get import fields
!      SetExport Subr. WMESMFMD Wave model set export fields
!      WMWAVE    Subr. WMWAVEMD Wave model run
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(ESMF_MAXSTR) :: cname
      integer, parameter :: iwt=5
      real(8) :: wstime, wftime
      integer :: stat, imod, tcur(2)
      integer, allocatable :: tend(:,:)
      integer(ESMF_KIND_I4) :: yy,mm,dd,h,m,s
      type(ESMF_Clock) :: clock
      type(ESMF_Time) :: currTime, stopTime
      real :: delt
      logical :: lerr
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_SUCCESS
      call ESMF_VMWtime(wstime)
      call ESMF_GridCompGet(gcomp, name=cname, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (verbosity.gt.0) call ESMF_LogWrite(trim(cname)// &
        ': entered ModelAdvance', ESMF_LOGMSG_INFO)

      allocate (tend(2,nrgrd), stat=rc)
      if (ESMF_LogFoundAllocError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! 1.  Advance model to requested end time
!
! 1.a Get component clock
!
      call ESMF_GridCompGet(gcomp, clock=clock, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 1.b Report
!
      if ( improc .eq. nmpscr ) then
        write(*,'(///)')
        call ESMF_ClockPrint(clock, options="currTime", &
          preString="-->Advancing "//TRIM(cname)//" from: ")
        call ESMF_ClockPrint(clock, options="stopTime", &
          preString="-----------------> to: ")
      endif
!
! 1.c Check internal current time with component current time
!
      call ESMF_ClockGet(clock, currTime=currTime, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_TimeGet(currTime, yy=yy,mm=mm,dd=dd,h=h,m=m,s=s, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      lerr=.false.
      do imod = 1,nrgrd
        tcur(1) = 10000*yy + 100*mm + dd
        tcur(2) = 10000*h  + 100*m  + s
        call w3setw ( imod, mdse, mdst )
        delt = dsec21 ( time, tcur )
        if ( abs(delt).gt.0 ) then
          lerr=.true.
          write(msg,'(a,i2,a,2(a,i8,a,i8,a))') &
            'Wave model grid ',imod,': ', &
            'Internal time (',time(1),'.',time(2),') /= ', &
            'Component time (',tcur(1),'.',tcur(2),')'
          call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_ERROR)
        endif
      enddo
      if (lerr) then
        rc = ESMF_FAILURE
        return
      endif
!
! 1.d Set end time of this advance
!
      call ESMF_ClockGet(clock, stopTime=stopTime, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_TimeGet(stopTime, yy=yy,mm=mm,dd=dd,h=h,m=m,s=s, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      do imod = 1,nrgrd
        tend(1,imod) = 10000*yy + 100*mm + dd
        tend(2,imod) = 10000*h  + 100*m  + s
      enddo
!
! 1.e Get import fields
!
      call GetImport(gcomp, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 1.f Advance model
!
      call wmwave ( tend )
!
! 1.g Set export fields
!
      call SetExport(gcomp, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! Post
!
      deallocate (tend, stat=rc)
      if (ESMF_LogFoundDeallocError(rc, PASSTHRU)) return
      rc = ESMF_SUCCESS
      call ESMF_VMWtime(wftime)
      wtime(iwt) = wtime(iwt) + wftime - wstime
      wtcnt(iwt) = wtcnt(iwt) + 1
      if (verbosity.gt.0) call ESMF_LogWrite(trim(cname)// &
        ': leaving ModelAdvance', ESMF_LOGMSG_INFO)
!/
!/ End of ModelAdvance ----------------------------------------------- /
!/
      end subroutine ModelAdvance
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "GetImport"
      subroutine GetImport ( gcomp, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         20-Jan-2017 |
!/                  +-----------------------------------+
!/
!/    20-Jan-2017 : Origination.                        ( version 6.02 )
!/
!  1. Purpose :
!
!     Get import fields and put in internal data structures
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp     Type   I/O Gridded component
!       rc        Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      NONE
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(ESMF_MAXSTR) :: cname
      integer, parameter :: iwt=7
      real(8) :: wstime, wftime
      integer :: i1, i2, i3, j, imod, jmod
      logical, save :: firstCall = .true.
      integer :: tcur(2), tend(2)
      integer(ESMF_KIND_I4) :: yy,mm,dd,h,m,s
      type(ESMF_Clock) :: clock
      type(ESMF_Time) :: currTime, stopTime
#if defined(TEST_WMESMFMD) || defined(TEST_WMESMFMD_GETIMPORT)
      type(ESMF_State) :: dumpState
      integer, save :: timeSlice = 1
#endif
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_SUCCESS
      if ( noActiveImpFields ) return
      call ESMF_VMWtime(wstime)
      call ESMF_GridCompGet(gcomp, name=cname, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (verbosity.gt.0) call ESMF_LogWrite(trim(cname)// &
        ': entered GetImport', ESMF_LOGMSG_INFO)
#if defined(TEST_WMESMFMD) || defined(TEST_WMESMFMD_GETIMPORT)
      call NUOPC_ModelGet(gcomp, importState=dumpState, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call NUOPC_Write(dumpState, overwrite=.true., &
        fileNamePrefix="field_"//trim(cname)//"_import1_", &
        timeslice=timeSlice, relaxedFlag=.true., rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
#endif
!
! -------------------------------------------------------------------- /
! 1.  Setup
!
! 1.a Setup time stamps using currTime and stopTime
!
      call ESMF_GridCompGet(gcomp, clock=clock, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_ClockGet(clock, currTime=currTime, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_TimeGet(currTime, yy=yy,mm=mm,dd=dd,h=h,m=m,s=s, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      tcur(1) = 10000*yy + 100*mm + dd
      tcur(2) = 10000*h  + 100*m  + s
      call ESMF_ClockGet(clock, stopTime=stopTime, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_TimeGet(stopTime, yy=yy,mm=mm,dd=dd,h=h,m=m,s=s, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      tend(1) = 10000*yy + 100*mm + dd
      tend(2) = 10000*h  + 100*m  + s
!
! -------------------------------------------------------------------- /
! 2.  Water levels
!
      j = 1
      i1 = FieldIndex( impFieldName, 'seahgt', rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      i2 = i1
      if ( isActiveImpField(i1) ) then
        call w3setg ( impGridID, mdse, mdst )
        call w3seti ( impGridID, mdse, mdst )
        if (firstCall) then
          tln = tcur
        else
          tln = tend
        endif
        tfn(:,j) = tln
        if ( isActiveMbgField(i1) ) then
          call BlendImpFields( impField(i1), mbgField(i1), &
            missingValue, rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
        endif
        call FieldGather( impField(i1), nx, ny, wlev, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        do imod = 1,nrgrd
          call w3setg ( imod, mdse, mdst )
          call w3setw ( imod, mdse, mdst )
          call w3seti ( imod, mdse, mdst )
          call w3seto ( imod, mdse, mdst )
          call wmsetm ( imod, mdse, mdst )
!/MPI          if ( mpi_comm_grd .eq. mpi_comm_null ) cycle
          jmod = inpmap(imod,j)
          if ( jmod.lt.0 .and. jmod.ne.-999 ) then
            call wmupd2( imod, j, jmod, rc )
            if (ESMF_LogFoundError(rc, PASSTHRU)) return
          endif
        enddo
      endif
!
! -------------------------------------------------------------------- /
! 3.  Currents
!
      j = 2
      i1 = FieldIndex( impFieldName, 'uucurr', rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      i2 = FieldIndex( impFieldName, 'vvcurr', rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if ( isActiveImpField(i1) ) then
        call w3setg ( impGridID, mdse, mdst )
        call w3seti ( impGridID, mdse, mdst )
        if (firstCall) then
          tcn = tcur
        else
          tc0 = tcn
          cx0 = cxn
          cy0 = cyn
          tcn = tend
        endif
        tfn(:,j) = tcn
        if ( isActiveMbgField(i1) ) then
          call BlendImpFields( impField(i1), mbgField(i1), &
            missingValue, rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
          call BlendImpFields( impField(i2), mbgField(i2), &
            missingValue, rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
        endif
        call FieldGather( impField(i1), nx, ny, cxn, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call FieldGather( impField(i2), nx, ny, cyn, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        if (firstCall) then
          tc0 = tcn
          cx0 = cxn
          cy0 = cyn
        endif
        do imod = 1,nrgrd
          call w3setg ( imod, mdse, mdst )
          call w3setw ( imod, mdse, mdst )
          call w3seti ( imod, mdse, mdst )
          call wmsetm ( imod, mdse, mdst )
!/MPI          if ( mpi_comm_grd .eq. mpi_comm_null ) cycle
          jmod = inpmap(imod,j)
          if ( jmod.lt.0 .and. jmod.ne.-999 ) then
            call wmupd2( imod, j, jmod, rc )
            if (ESMF_LogFoundError(rc, PASSTHRU)) return
          endif
        enddo
      endif
!
! -------------------------------------------------------------------- /
! 4.  Winds
!
      j = 3
      i1 = FieldIndex( impFieldName, 'uutrue', rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      i2 = FieldIndex( impFieldName, 'vvtrue', rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if ( isActiveImpField(i1) ) then
        call w3setg ( impGridID, mdse, mdst )
        call w3seti ( impGridID, mdse, mdst )
        if (firstCall) then
          twn = tcur
        else
          tw0 = twn
          wx0 = wxn
          wy0 = wyn
          twn = tend
        endif
        tfn(:,j) = twn
        if ( isActiveMbgField(i1) ) then
          call BlendImpFields( impField(i1), mbgField(i1), &
            missingValue, rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
          call BlendImpFields( impField(i2), mbgField(i2), &
            missingValue, rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
        endif
        call FieldGather( impField(i1), nx, ny, wxn, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call FieldGather( impField(i2), nx, ny, wyn, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        if (firstCall) then
          tw0 = twn
          wx0 = wxn
          wy0 = wyn
        endif
        do imod = 1,nrgrd
          call w3setg ( imod, mdse, mdst )
          call w3setw ( imod, mdse, mdst )
          call w3seti ( imod, mdse, mdst )
          call wmsetm ( imod, mdse, mdst )
!/MPI          if ( mpi_comm_grd .eq. mpi_comm_null ) cycle
          jmod = inpmap(imod,j)
          if ( jmod.lt.0 .and. jmod.ne.-999 ) then
            call wmupd2( imod, j, jmod, rc )
            if (ESMF_LogFoundError(rc, PASSTHRU)) return
          endif
        enddo
      endif
!
! -------------------------------------------------------------------- /
! 5.  Sea ice concentration
!
      j = 4
      i1 = FieldIndex( impFieldName, 'seaice', rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      i2 = i1
      if ( isActiveImpField(i1) ) then
        call w3setg ( impGridID, mdse, mdst )
        call w3seti ( impGridID, mdse, mdst )
        if (firstCall) then
          tin = tcur
        else
          tin = tend
        endif
        tfn(:,j) = tin
        if ( isActiveMbgField(i1) ) then
          call BlendImpFields( impField(i1), mbgField(i1), &
            missingValue, rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
        endif
        call FieldGather( impField(i1), nx, ny, icei, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        do imod = 1,nrgrd
          call w3setg ( imod, mdse, mdst )
          call w3setw ( imod, mdse, mdst )
          call w3seti ( imod, mdse, mdst )
          call wmsetm ( imod, mdse, mdst )
!/MPI          if ( mpi_comm_grd .eq. mpi_comm_null ) cycle
          jmod = inpmap(imod,j)
          if ( jmod.lt.0 .and. jmod.ne.-999 ) then
            call wmupd2( imod, j, jmod, rc )
            if (ESMF_LogFoundError(rc, PASSTHRU)) return
          endif
        enddo
      endif
!
! -------------------------------------------------------------------- /
! Post
!
#if defined(TEST_WMESMFMD) || defined(TEST_WMESMFMD_GETIMPORT)
      call NUOPC_Write(dumpState, overwrite=.true., &
        fileNamePrefix="field_"//trim(cname)//"_import2_", &
        timeslice=timeSlice, relaxedFlag=.true., rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      timeSlice = timeSlice + 1
#endif
      firstCall = .false.
      rc = ESMF_SUCCESS
      call ESMF_VMWtime(wftime)
      wtime(iwt) = wtime(iwt) + wftime - wstime
      wtcnt(iwt) = wtcnt(iwt) + 1
      if (verbosity.gt.0) call ESMF_LogWrite(trim(cname)// &
        ': leaving GetImport', ESMF_LOGMSG_INFO)
!/
!/ End of GetImport -------------------------------------------------- /
!/
      end subroutine GetImport
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "SetExport"
      subroutine SetExport ( gcomp, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         20-Jan-2017 |
!/                  +-----------------------------------+
!/
!/    20-Jan-2017 : Origination.                        ( version 6.02 )
!/
!  1. Purpose :
!
!     Set export fields from internal data structures
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp     Type   I/O Gridded component
!       rc        Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      NONE
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(ESMF_MAXSTR) :: cname
      integer, parameter :: iwt=8
      real(8) :: wstime, wftime
      integer :: i1, i2, i3, isea, jsea
      logical, save :: firstCall = .true.
      type(ESMF_Field) :: natField
      real(ESMF_KIND_RX), pointer :: natPtr(:)
      real(ESMF_KIND_RX) :: fillValue
      real    :: emean, fmean, fmean1, wnmean, amax, ustar, ustdr, &
                 tauwx, tauwy, cd, z0, fmeanws
      logical :: llws(nspec)
      real    :: z0wave(nseal)
#if defined(TEST_WMESMFMD) || defined(TEST_WMESMFMD_SETEXPORT)
      type(ESMF_State) :: dumpState
      integer, save :: timeSlice = 1
#endif
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_SUCCESS
      if ( noActiveExpFields ) return
      call ESMF_VMWtime(wstime)
      call ESMF_GridCompGet(gcomp, name=cname, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (verbosity.gt.0) call ESMF_LogWrite(trim(cname)// &
        ': entered SetExport', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! 1.  Setup
!
! 1.a Set pointers for model grid
!
      call w3setg ( expGridID, mdse, mdst )
      call w3setw ( expGridID, mdse, mdst )
      call w3seta ( expGridID, mdse, mdst )
      call w3seti ( expGridID, mdse, mdst )
      call w3seto ( expGridID, mdse, mdst )
      call wmsetm ( expGridID, mdse, mdst )
!
! 1.b Create temporary field on native grid
!
      natField = ESMF_FieldCreate( natGrid, natArraySpec1D, &
        staggerLoc=natStaggerLoc, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! 2.  Charnock
!
      i1 = FieldIndex( expFieldName, 'charno', rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if ( isActiveExpField(i1) ) then
        fillValue = zeroValue
        if ( natGridIsLocal ) then
          call FieldFill( natField, fillValue, rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
          if ( firstCall ) then
            do jsea = 1,nseal
!/DIST              isea = iaproc + (jsea-1)*naproc
!/SHRD              isea = jsea
!/ST0              charn(jsea) = fillValue
!/ST1              charn(jsea) = fillValue
!/ST2              charn(jsea) = fillValue
!/ST3              llws(:) = .true.
!/ST3              ustar = 0.
!/ST3              ustdr = 0.
!/ST3              call w3spr3( va(:,jsea), cg(1:nk,isea), wn(1:nk,isea),   &
!/ST3                           emean, fmean, fmean1, wnmean, amax,         &
!/ST3                           u10(isea), u10d(isea), ustar, ustdr, tauwx, &
!/ST3                           tauwy, cd, z0, charn(jsea), llws, fmeanws )
!/ST4              llws(:) = .true.
!/ST4              ustar = 0.
!/ST4              ustdr = 0.
!/ST4              call w3spr4( va(:,jsea), cg(1:nk,isea), wn(1:nk,isea),   &
!/ST4                           emean, fmean, fmean1, wnmean, amax,         &
!/ST4                           u10(isea), u10d(isea), ustar, ustdr, tauwx, &
!/ST4                           tauwy, cd, z0, charn(jsea), llws, fmeanws )
!/ST6              charn(jsea) = fillValue
            enddo
          endif
          call ESMF_FieldGet( natField, farrayPtr=natPtr, rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
          natPtr(1:nseal) = charn(1:nseal)
        endif
        call ESMF_FieldRedist( natField, expField(i1), n2eRH, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      endif
!
! -------------------------------------------------------------------- /
! 3.  Surface Roughness 
!
      i1 = FieldIndex( expFieldName, 'z0rlen', rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if ( isActiveExpField(i1) ) then
        fillValue = zeroValue
        if ( natGridIsLocal ) then
          call FieldFill( natField, fillValue, rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
          if ( firstCall ) then
            z0wave = fillValue
          else
            do jsea = 1,nseal
!/DIST              isea = iaproc + (jsea-1)*naproc
!/SHRD              isea = jsea 
              z0wave(jsea) = charn(jsea)*ust(isea)**2/grav
!/ST0              z0wave(jsea) = fillValue !no charn calculated
            enddo
          endif
          call ESMF_FieldGet( natField, farrayPtr=natPtr, rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
          natPtr(1:nseal) = z0wave(1:nseal)
        endif
        call ESMF_FieldRedist( natField, expField(i1), n2eRH, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      endif
!
! -------------------------------------------------------------------- /
! 4.  Stokes Drift
!
!
! -------------------------------------------------------------------- /
! 5.  Bottom Current
!
!
! -------------------------------------------------------------------- /
! 6.  Clean up
!
      call ESMF_FieldDestroy( natField, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! Post
!
#if defined(TEST_WMESMFMD) || defined(TEST_WMESMFMD_SETEXPORT)
      call NUOPC_ModelGet(gcomp, exportState=dumpState, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call NUOPC_Write(dumpState, overwrite=.true., &
        fileNamePrefix="field_"//trim(cname)//"_export_", &
        timeslice=timeSlice, relaxedFlag=.true., rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      timeSlice = timeSlice + 1
#endif
      firstCall = .false.
      rc = ESMF_SUCCESS
      call ESMF_VMWtime(wftime)
      wtime(iwt) = wtime(iwt) + wftime - wstime
      wtcnt(iwt) = wtcnt(iwt) + 1
      if (verbosity.gt.0) call ESMF_LogWrite(trim(cname)// &
        ': leaving SetExport', ESMF_LOGMSG_INFO)
!/
!/ End of SetExport -------------------------------------------------- /
!/
      end subroutine SetExport
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "CreateImpGrid"
      subroutine CreateImpGrid ( gcomp, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         20-Jan-2017 |
!/                  +-----------------------------------+
!/
!/    20-Jan-2017 : Origination.                        ( version 6.02 )
!/
!  1. Purpose :
!
!     Create ESMF grid for import fields
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp     Type   I/O Gridded component
!       rc        Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      NONE
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(ESMF_MAXSTR) :: cname
      integer :: nproc, nxproc, nyproc, n, nfac, irp
      real    :: gr, rp, pr, diff
      integer, parameter :: lde = 0
      integer :: ldecnt
      integer :: ix, iy, isea, jsea
      integer :: elb(2), eub(2)
      integer :: tlb(2), tub(2)
      integer(ESMF_KIND_I4), pointer :: iptr(:,:)
      real(ESMF_KIND_RX), pointer :: rptrx(:,:), rptry(:,:)
      real(ESMF_KIND_RX), pointer :: rptr(:,:)
      type(ESMF_Field) :: tmpField
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_SUCCESS
      if ( noActiveImpFields ) return
      call ESMF_GridCompGet(gcomp, name=cname, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (verbosity.gt.0) call ESMF_LogWrite(trim(cname)// &
        ': entered CreateImpGrid', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! 1.  Setup
!
! 1.a Set grid pointers
!
      impGridID = minval(inpmap)
      if ( impGridID.eq.-999 ) impGridID = 1
      call w3setg ( impGridID, mdse, mdst )
      call w3seti ( impGridID, mdse, mdst )
      call w3seto ( impGridID, mdse, mdst )
      if ( impGridID.gt.0 ) then
        call wmsetm ( impGridID, mdse, mdst )
        nproc = naproc
      else
        nproc = nmproc
      endif
!
! 1.b Compute a 2D subdomain layout based on nproc
!
      if ( nx.gt.ny ) then
        gr = real(nx)/real(ny)
      else
        gr = real(ny)/real(nx)
      endif
      irp = int(sqrt(real(nproc)))
      diff = huge(gr)
      nfac = nproc
      do n = irp,nproc
        if ( mod(nproc,n).ne.0 ) cycle
        pr = real(n**2)/real(nproc)
        if ( abs(gr-pr) < diff ) then
          diff = abs(gr-pr)
          nfac = n
        endif
      enddo
      if ( nx.gt.ny ) then
        nxproc = nfac
        nyproc = nproc/nfac
      else
        nxproc = nproc/nfac
        nyproc = nfac
      endif
!
! 1.c Set arraySpec, staggerLoc, and indexFlag for import fields
!
      call ESMF_ArraySpecSet( impArraySpec2D, rank=2, &
        typekind=ESMF_TYPEKIND_RX, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      impStaggerLoc = ESMF_STAGGERLOC_CENTER
      impIndexFlag = ESMF_INDEX_GLOBAL
!
! -------------------------------------------------------------------- /
! 2.  Create ESMF grid for import with 2D subdomain layout
!     Note that the ESMF grid layout is dim1=X, dim2=Y
!
! 2.a Create ESMF import grid
!
      select case (iclose)
        case (iclose_none)
          impGrid = ESMF_GridCreateNoPeriDim( &
            minIndex=(/ 1, 1/), &
            maxIndex=(/nx,ny/), &
            coordDep1=(/1,2/), &
            coordDep2=(/1,2/), &
            regDecomp=(/nxproc,nyproc/), &
            decompFlag=(/ESMF_DECOMP_BALANCED,ESMF_DECOMP_BALANCED/), &
            coordTypeKind=ESMF_TYPEKIND_RX, &
            coordSys=ESMF_COORDSYS_SPH_DEG, &
            indexFlag=impIndexFlag, &
            name=trim(cname)//"_import_grid", rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
        case (iclose_smpl)
          impGrid = ESMF_GridCreate1PeriDim( &
            periodicDim=1, &
            poleDim=2, &
            poleKindFlag=(/ESMF_POLEKIND_NONE,ESMF_POLEKIND_NONE/), &
            minIndex=(/ 1, 1/), &
            maxIndex=(/nx,ny/), &
            coordDep1=(/1,2/), &
            coordDep2=(/1,2/), &
            regDecomp=(/nxproc,nyproc/), &
            decompFlag=(/ESMF_DECOMP_BALANCED,ESMF_DECOMP_BALANCED/), &
            coordTypeKind=ESMF_TYPEKIND_RX, &
            coordSys=ESMF_COORDSYS_SPH_DEG, &
            indexFlag=impIndexFlag, &
            name=trim(cname)//"_import_grid", rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
        case default
          write(msg,'(a,i1,a)') 'Index closure ',iclose, &
            ' not supported for import grid'
          call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_ERROR)
          rc = ESMF_FAILURE
          return
      endselect
!
! 2.b Add coordinate arrays and land/sea mask to import grid
!
      call ESMF_GridAddCoord( impGrid, staggerLoc=impStaggerLoc, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_GridAddItem( impGrid, ESMF_GRIDITEM_MASK, &
        staggerLoc=impStaggerLoc, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 2.c Set flag to indicate that this processor has local import grid storage
!
      call ESMF_GridGet( impGrid, localDECount=ldecnt, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      impGridIsLocal = ldecnt.gt.0
!
! 2.d Get exclusive bounds (global index) for import grid
!
      if ( impGridIsLocal ) then
        call ESMF_GridGet( impGrid, impStaggerLoc, lde, &
          exclusiveLBound=elb, exclusiveUBound=eub, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      endif
!
! 2.e Set halo widths for import fields
!
      if ( impGridIsLocal ) then
        impHaloLWidth = (/haloWidth,haloWidth/)
        impHaloUWidth = (/haloWidth,haloWidth/)
        select case (iclose)
          case (iclose_none)
            if ( elb(1).eq.1  ) impHaloLWidth(1) = 0
            if ( elb(2).eq.1  ) impHaloLWidth(2) = 0
            if ( eub(1).eq.nx ) impHaloUWidth(1) = 0
            if ( eub(2).eq.ny ) impHaloUWidth(2) = 0
          case (iclose_smpl)
            if ( elb(2).eq.1  ) impHaloLWidth(2) = 0
            if ( eub(2).eq.ny ) impHaloUWidth(2) = 0
        endselect
      else
        impHaloLWidth = (/0,0/)
        impHaloUWidth = (/0,0/)
      endif
!
! 2.f Set ESMF import grid coordinates
!
      if ( impGridIsLocal ) then
        call ESMF_GridGetCoord( impGrid, 1, localDE=lde, &
          staggerLoc=impStaggerLoc, farrayPtr=rptrx, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call ESMF_GridGetCoord( impGrid, 2, localDE=lde, &
          staggerLoc=impStaggerLoc, farrayPtr=rptry, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        do iy = elb(2),eub(2)
          do ix = elb(1),eub(1)
            rptrx(ix,iy) = xgrd(iy,ix)
            rptry(ix,iy) = ygrd(iy,ix)
          enddo
        enddo
      endif
!
! 2.g Set ESMF import grid land/sea mask values.
!     Land/sea mask is fixed in time and based on excluded points only.
!
      if ( impGridIsLocal ) then
        call ESMF_GridGetItem( impGrid, ESMF_GRIDITEM_MASK, localDE=lde, &
          staggerLoc=impStaggerLoc, farrayPtr=iptr, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        do iy = elb(2),eub(2)
          do ix = elb(1),eub(1)
            if ( mapsta(iy,ix).ne.0 ) then
              iptr(ix,iy) = maskValueWater
            else
              iptr(ix,iy) = maskValueLand
            endif
          enddo
        enddo
      endif
!
! -------------------------------------------------------------------- /
! 3.  Create import field mask and routeHandle halo update
!
! 3.a Create field for import grid land/sea mask.
!
      impMask = ESMF_FieldCreate( impGrid, impArraySpec2D, &
        totalLWidth=impHaloLWidth, totalUWidth=impHaloUWidth, &
        staggerLoc=impStaggerLoc, indexFlag=impIndexFlag, &
        name='mask', rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 3.b Store import field halo routeHandle
!
      call ESMF_FieldHaloStore( impMask, routeHandle=impHaloRH, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 3.c Set import field land/sea mask values and update halos
!
      if ( impGridIsLocal ) then
        call ESMF_FieldGet( impMask, localDE=lde, farrayPtr=rptr, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        do iy = elb(2),eub(2)
          do ix = elb(1),eub(1)
            rptr(ix,iy) = iptr(ix,iy)
          enddo
        enddo
      endif

      call ESMF_FieldHalo( impMask, impHaloRH, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! Post
!
#if defined(TEST_WMESMFMD) || defined(TEST_WMESMFMD_CREATEIMPGRID)
      call ESMF_FieldWrite( impMask, &
        "wmesmfmd_createimpgrid_import_mask.nc", overwrite=.true., rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      tmpField = ESMF_FieldCreate( impGrid, impArraySpec2D, &
        totalLWidth=impHaloLWidth, totalUWidth=impHaloUWidth, &
        staggerLoc=impStaggerLoc, indexFlag=impIndexFlag, &
        name='temp', rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if ( impGridIsLocal ) then
        call ESMF_FieldGet( tmpField, localDE=lde, farrayPtr=rptr, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      endif
      if ( impGridIsLocal ) then
        do iy = elb(2),eub(2)
          do ix = elb(1),eub(1)
            rptr(ix,iy) = xgrd(iy,ix)
          enddo
        enddo
      endif
      call ESMF_FieldWrite( tmpField, &
        "wmesmfmd_createimpgrid_import_xgrd.nc", overwrite=.true., rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if ( impGridIsLocal ) then
        do iy = elb(2),eub(2)
          do ix = elb(1),eub(1)
            rptr(ix,iy) = ygrd(iy,ix)
          enddo
        enddo
      endif
      call ESMF_FieldWrite( tmpField, &
        "wmesmfmd_createimpgrid_import_ygrd.nc", overwrite=.true., rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if ( impGridIsLocal ) then
        do iy = elb(2),eub(2)
          do ix = elb(1),eub(1)
            rptr(ix,iy) = hpfac(iy,ix)
          enddo
        enddo
      endif
      call ESMF_FieldWrite( tmpField, &
        "wmesmfmd_createimpgrid_import_hpfac.nc", overwrite=.true., rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if ( impGridIsLocal ) then
        do iy = elb(2),eub(2)
          do ix = elb(1),eub(1)
            rptr(ix,iy) = hqfac(iy,ix)
          enddo
        enddo
      endif
      call ESMF_FieldWrite( tmpField, &
        "wmesmfmd_createimpgrid_import_hqfac.nc", overwrite=.true., rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_FieldDestroy( tmpField, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
#endif
!
      rc = ESMF_SUCCESS
      if (verbosity.gt.0) call ESMF_LogWrite(trim(cname)// &
        ': leaving CreateImpGrid', ESMF_LOGMSG_INFO)
!/
!/ End of CreateImpGrid ---------------------------------------------- /
!/
      end subroutine CreateImpGrid
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "CreateExpGrid"
      subroutine CreateExpGrid ( gcomp, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         20-Jan-2017 |
!/                  +-----------------------------------+
!/
!/    20-Jan-2017 : Origination.                        ( version 6.02 )
!/
!  1. Purpose :
!
!     Create ESMF grid for export fields
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp     Type   I/O Gridded component
!       rc        Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      NONE
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
!       !/SHRD  Switch for shared / distributed memory architecture.
!       !/DIST  Id.
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(ESMF_MAXSTR) :: cname
      integer :: nproc, nxproc, nyproc, n, nfac, irp
      real    :: gr, rp, pr, diff
      integer, parameter :: lde = 0
      integer :: ldecnt
      integer :: ix, iy, isea, jsea
      integer :: elb(2), eub(2)
      integer(ESMF_KIND_I4), pointer :: iptr(:,:)
      real(ESMF_KIND_RX), pointer :: rptrx(:,:), rptry(:,:)
      real(ESMF_KIND_RX), pointer :: rptr(:,:)
      integer :: arbIndexCount
      integer, allocatable :: arbIndexList(:,:)
      type(ESMF_Field) :: nField, eField
      type(ESMF_Field) :: tmpField
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_SUCCESS
      if ( noActiveExpFields ) return
      call ESMF_GridCompGet(gcomp, name=cname, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (verbosity.gt.0) call ESMF_LogWrite(trim(cname)// &
        ': entered CreateExpGrid', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! 1.  Setup
!
! 1.a Set grid pointers
!
      expGridID = 1 !TODO: only export from grid 1
      call w3setg ( expGridID, mdse, mdst )
      call w3setw ( expGridID, mdse, mdst )
      call w3seta ( expGridID, mdse, mdst )
      call w3seti ( expGridID, mdse, mdst )
      call w3seto ( expGridID, mdse, mdst )
      call wmsetm ( expGridID, mdse, mdst )
      natGridID = expGridID
      nproc = naproc
!
! 1.b Compute a 2D subdomain layout based on nproc
!
      if ( nx.gt.ny ) then
        gr = real(nx)/real(ny)
      else
        gr = real(ny)/real(nx)
      endif
      irp = int(sqrt(real(nproc)))
      diff = huge(gr)
      nfac = nproc
      do n = irp,nproc
        if ( mod(nproc,n).ne.0 ) cycle
        pr = real(n**2)/real(nproc)
        if ( abs(gr-pr) < diff ) then
          diff = abs(gr-pr)
          nfac = n
        endif
      enddo
      if ( nx.gt.ny ) then
        nxproc = nfac
        nyproc = nproc/nfac
      else
        nxproc = nproc/nfac
        nyproc = nfac
      endif
!
! 1.c Set arraySpec, staggerLoc, and indexFlag for export fields
!
      call ESMF_ArraySpecSet( expArraySpec2D, rank=2, &
        typekind=ESMF_TYPEKIND_RX, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_ArraySpecSet( expArraySpec3D, rank=3, &
        typekind=ESMF_TYPEKIND_RX, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      expStaggerLoc = ESMF_STAGGERLOC_CENTER
      expIndexFlag = ESMF_INDEX_GLOBAL
!
! 1.d Set arraySpec, staggerLoc, and indexFlag for native fields
!
      call ESMF_ArraySpecSet( natArraySpec1D, rank=1, &
        typekind=ESMF_TYPEKIND_RX, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      natStaggerLoc = ESMF_STAGGERLOC_CENTER
      natIndexFlag = ESMF_INDEX_DELOCAL
!
! -------------------------------------------------------------------- /
! 2.  Create ESMF grid for export with 2D subdomain layout
!     Note that the ESMF grid layout is dim1=X, dim2=Y
!
! 2.a Create ESMF export grid
!
      select case (iclose)
        case (iclose_none)
          expGrid = ESMF_GridCreateNoPeriDim( &
            minIndex=(/ 1, 1/), &
            maxIndex=(/nx,ny/), &
            coordDep1=(/1,2/), &
            coordDep2=(/1,2/), &
            regDecomp=(/nxproc,nyproc/), &
            decompFlag=(/ESMF_DECOMP_BALANCED,ESMF_DECOMP_BALANCED/), &
            coordTypeKind=ESMF_TYPEKIND_RX, &
            coordSys=ESMF_COORDSYS_SPH_DEG, &
            indexFlag=expIndexFlag, &
            name=trim(cname)//"_export_grid", rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
        case (iclose_smpl)
          expGrid = ESMF_GridCreate1PeriDim( &
            periodicDim=1, &
            poleDim=2, &
            poleKindFlag=(/ESMF_POLEKIND_NONE,ESMF_POLEKIND_NONE/), &
            minIndex=(/ 1, 1/), &
            maxIndex=(/nx,ny/), &
            coordDep1=(/1,2/), &
            coordDep2=(/1,2/), &
            regDecomp=(/nxproc,nyproc/), &
            decompFlag=(/ESMF_DECOMP_BALANCED,ESMF_DECOMP_BALANCED/), &
            coordTypeKind=ESMF_TYPEKIND_RX, &
            coordSys=ESMF_COORDSYS_SPH_DEG, &
            indexFlag=expIndexFlag, &
            name=trim(cname)//"_export_grid", rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
        case default
          write(msg,'(a,i1,a)') 'Index closure ',iclose, &
            ' not supported for export grid'
          call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_ERROR)
          rc = ESMF_FAILURE
          return
      endselect
!
! 2.b Add coordinate arrays and land/sea mask to export grid
!
      call ESMF_GridAddCoord( expGrid, staggerLoc=expStaggerLoc, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_GridAddItem( expGrid, ESMF_GRIDITEM_MASK, &
        staggerLoc=expStaggerLoc, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 2.c Set flag to indicate that this processor has local export grid storage
!
      call ESMF_GridGet( expGrid, localDECount=ldecnt, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      expGridIsLocal = ldecnt.gt.0
!
! 2.d Get exclusive bounds (global index) for export grid
!
      if ( expGridIsLocal ) then
        call ESMF_GridGet( expGrid, expStaggerLoc, lde, &
          exclusiveLBound=elb, exclusiveUBound=eub, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      endif
!
! 2.e Set halo widths for export fields
!
      if ( expGridIsLocal ) then
        expHaloLWidth = (/haloWidth,haloWidth/)
        expHaloUWidth = (/haloWidth,haloWidth/)
        select case (iclose)
          case (iclose_none)
            if ( elb(1).eq.1  ) expHaloLWidth(1) = 0
            if ( elb(2).eq.1  ) expHaloLWidth(2) = 0
            if ( eub(1).eq.nx ) expHaloUWidth(1) = 0
            if ( eub(2).eq.ny ) expHaloUWidth(2) = 0
          case (iclose_smpl)
            if ( elb(2).eq.1  ) expHaloLWidth(2) = 0
            if ( eub(2).eq.ny ) expHaloUWidth(2) = 0
        endselect
      else
        expHaloLWidth = (/0,0/)
        expHaloUWidth = (/0,0/)
      endif
!
! 2.f Set ESMF export grid coordinate
!
      if ( expGridIsLocal ) then
        call ESMF_GridGetCoord( expGrid, 1, localDE=lde, &
          staggerLoc=expStaggerLoc, farrayPtr=rptrx, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call ESMF_GridGetCoord( expGrid, 2, localDE=lde, &
          staggerLoc=expStaggerLoc, farrayPtr=rptry, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        do iy = elb(2),eub(2)
          do ix = elb(1),eub(1)
            rptrx(ix,iy) = xgrd(iy,ix)
            rptry(ix,iy) = ygrd(iy,ix)
          enddo
        enddo
      endif
!
! 2.g Set ESMF export grid land/sea mask values.
!     Land/sea mask is fixed in time and based on excluded points only.
!
      if ( expGridIsLocal ) then
        call ESMF_GridGetItem( expGrid, ESMF_GRIDITEM_MASK, localDE=lde, &
          staggerLoc=expStaggerLoc, farrayPtr=iptr, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        do iy = elb(2),eub(2)
          do ix = elb(1),eub(1)
            if ( mapsta(iy,ix).ne.0 ) then
              iptr(ix,iy) = maskValueWater
            else
              iptr(ix,iy) = maskValueLand
            endif
          enddo
        enddo
      endif
!
! -------------------------------------------------------------------- /
! 3.  Create export field mask and routeHandle halo update
!
! 3.a Create field for export grid land/sea mask.
!
      expMask = ESMF_FieldCreate( expGrid, expArraySpec2D, &
        totalLWidth=expHaloLWidth, totalUWidth=expHaloUWidth, &
        staggerLoc=expStaggerLoc, indexFlag=expIndexFlag, &
        name='mask', rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 3.b Store export field halo routeHandle
!
      call ESMF_FieldHaloStore( expMask, routeHandle=expHaloRH, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 3.c Set export field land/sea mask values and update halos
!
      if ( expGridIsLocal ) then
        call ESMF_FieldGet( expMask, localDE=lde, farrayPtr=rptr, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        do iy = elb(2),eub(2)
          do ix = elb(1),eub(1)
            rptr(ix,iy) = iptr(ix,iy)
          enddo
        enddo
      endif

      call ESMF_FieldHalo( expMask, expHaloRH, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! 4.  Create ESMF grid with arbitrary domain decomposition to match
!     the native domain decomposition of the non-excluded points
!     Note that the native grid layout is dim1=Y, dim2=X
!     Note that coordinates and mask are not needed since this
!     grid is only used to define fields for a redist operation
!
! 4.a Set flag to indicate that this processor has local native grid storage
!
      natGridIsLocal = iaproc .gt. 0 .and. iaproc .le. naproc
!
! 4.b Setup arbitrary sequence index list
!
      do ipass = 1,2
        if (ipass.eq.2) then
          allocate (arbIndexList(arbIndexCount,2), stat=rc)
          if (ESMF_LogFoundAllocError(rc, PASSTHRU)) return
        endif
        arbIndexCount = 0
        ! list local native grid non-excluded points
        if ( natGridIsLocal ) then
          do jsea = 1,nseal
!/DIST            isea = iaproc + (jsea-1)*naproc
!/SHRD            isea = jsea
            arbIndexCount = arbIndexCount+1
            if (ipass.eq.2) then
              ix = mapsf(isea,1)
              iy = mapsf(isea,2)
              ! native grid layout: dim1=Y, dim2=X
              arbIndexList(arbIndexCount,1) = iy
              arbIndexList(arbIndexCount,2) = ix
            endif
          enddo
        endif
        ! list local export grid excluded points
        if ( expGridIsLocal ) then
          do iy = elb(2),eub(2)
            do ix = elb(1),eub(1)
              if ( mapsta(iy,ix).ne.0 ) cycle ! skip non-excluded point
              arbIndexCount = arbIndexCount+1
              if (ipass.eq.2) then
                ! native grid layout: dim1=Y, dim2=X
                arbIndexList(arbIndexCount,1) = iy
                arbIndexList(arbIndexCount,2) = ix
              endif
            enddo
          enddo
        endif
      enddo !ipass
!
! 4.c Create ESMF native grid
!
      select case (iclose)
        case (iclose_none)
          natGrid = ESMF_GridCreateNoPeriDim( &
            minIndex=(/ 1, 1/), &
            maxIndex=(/ny,nx/), &
            coordDep1=(/ESMF_DIM_ARB,ESMF_DIM_ARB/), &
            coordDep2=(/ESMF_DIM_ARB,ESMF_DIM_ARB/), &
            arbIndexCount=arbIndexCount, &
            arbIndexList=arbIndexList, &
            coordTypeKind=ESMF_TYPEKIND_RX, &
            coordSys=ESMF_COORDSYS_SPH_DEG, &
            name=trim(cname)//"_native_grid", rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
        case (iclose_smpl)
          natGrid = ESMF_GridCreate1PeriDim( &
            periodicDim=2, &
            poleDim=1, &
            poleKindFlag=(/ESMF_POLEKIND_NONE,ESMF_POLEKIND_NONE/), &
            minIndex=(/ 1, 1/), &
            maxIndex=(/ny,nx/), &
            coordDep1=(/ESMF_DIM_ARB,ESMF_DIM_ARB/), &
            coordDep2=(/ESMF_DIM_ARB,ESMF_DIM_ARB/), &
            arbIndexCount=arbIndexCount, &
            arbIndexList=arbIndexList, &
            coordTypeKind=ESMF_TYPEKIND_RX, &
            coordSys=ESMF_COORDSYS_SPH_DEG, &
            name=trim(cname)//"_native_grid", rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
        case default
          write(msg,'(a,i1,a)') 'Index closure ',iclose, &
            ' not supported for native grid'
          call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_ERROR)
          rc = ESMF_FAILURE
          return
      endselect
!
! 4.d Deallocate arbitrary sequence index list
!
      deallocate (arbIndexList, stat=rc)
      if (ESMF_LogFoundDeallocError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! 5.  Create route handle for redist between native grid domain
!     decomposition and the export grid domain decomposition
!
! 5.a Create temporary fields
!
      nField = ESMF_FieldCreate( natGrid, natArraySpec1D, &
        staggerLoc=natStaggerLoc, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      eField = ESMF_FieldCreate( expGrid, expArraySpec2D, &
        totalLWidth=expHaloLWidth, totalUWidth=expHaloUWidth, &
        staggerLoc=expStaggerLoc, indexFlag=expIndexFlag, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 5.b Store route handle
!
      call ESMF_FieldRedistStore( nField, eField, n2eRH, rc=rc ) 
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 5.c Clean up
!
      call ESMF_FieldDestroy( nField, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_FieldDestroy( eField, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! Post
!
#if defined(TEST_WMESMFMD) || defined(TEST_WMESMFMD_CREATEEXPGRID)
      call ESMF_FieldWrite( expMask, &
        "wmesmfmd_createexpgrid_export_mask.nc", overwrite=.true., rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      tmpField = ESMF_FieldCreate( expGrid, expArraySpec2D, &
        totalLWidth=expHaloLWidth, totalUWidth=expHaloUWidth, &
        staggerLoc=expStaggerLoc, indexFlag=expIndexFlag, &
        name='temp', rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if ( expGridIsLocal ) then
        call ESMF_FieldGet( tmpField, localDE=lde, farrayPtr=rptr, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      endif
      if ( expGridIsLocal ) then
        do iy = elb(2),eub(2)
          do ix = elb(1),eub(1)
            rptr(ix,iy) = xgrd(iy,ix)
          enddo
        enddo
      endif
      call ESMF_FieldWrite( tmpField, &
        "wmesmfmd_createexpgrid_export_xgrd.nc", overwrite=.true., rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if ( expGridIsLocal ) then
        do iy = elb(2),eub(2)
          do ix = elb(1),eub(1)
            rptr(ix,iy) = ygrd(iy,ix)
          enddo
        enddo
      endif
      call ESMF_FieldWrite( tmpField, &
        "wmesmfmd_createexpgrid_export_ygrd.nc", overwrite=.true., rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if ( expGridIsLocal ) then
        do iy = elb(2),eub(2)
          do ix = elb(1),eub(1)
            rptr(ix,iy) = hpfac(iy,ix)
          enddo
        enddo
      endif
      call ESMF_FieldWrite( tmpField, &
        "wmesmfmd_createexpgrid_export_hpfac.nc", overwrite=.true., rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if ( expGridIsLocal ) then
        do iy = elb(2),eub(2)
          do ix = elb(1),eub(1)
            rptr(ix,iy) = hqfac(iy,ix)
          enddo
        enddo
      endif
      call ESMF_FieldWrite( tmpField, &
        "wmesmfmd_createexpgrid_export_hqfac.nc", overwrite=.true., rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_FieldDestroy( tmpField, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
#endif
!
      rc = ESMF_SUCCESS
      if (verbosity.gt.0) call ESMF_LogWrite(trim(cname)// &
        ': leaving CreateExpGrid', ESMF_LOGMSG_INFO)
!/
!/ End of CreateExpGrid ---------------------------------------------- /
!/
      end subroutine CreateExpGrid
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "BlendImpFields"
      subroutine BlendImpFields( dstField, srcField, missingVal, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         20-Jan-2017 |
!/                  +-----------------------------------+
!/
!/    20-Jan-2017 : Origination.                        ( version 6.02 )
!/
!  1. Purpose :
!
!     Blend two import fields
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      NONE
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_Field)      :: dstField
      type(ESMF_Field)      :: srcField
      real(ESMF_KIND_RX)    :: missingVal
      integer, optional     :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      real(ESMF_KIND_RX), parameter :: zero = 0.0
      real(ESMF_KIND_RX), parameter :: half = 0.5
      real(ESMF_KIND_RX), parameter ::  one = 1.0
      integer, parameter :: nsig = haloWidth
      integer, parameter :: niter = 10
      integer, parameter :: lde = 0
      integer :: iter, i, j, ii, jj, k, l
      integer :: elb(2), eub(2)
      integer :: tlb(2), tub(2)
      real(ESMF_KIND_RX), pointer :: mptr(:,:), dptr(:,:), sptr(:,:)
      type(ESMF_Field) :: bmskField, cmskField
      real(ESMF_KIND_RX), pointer :: bmsk(:,:), cmsk(:,:)
      real(ESMF_KIND_RX) :: bsum, wsum
      real(ESMF_KIND_RX) :: wflt(-nsig:nsig,-nsig:nsig)
      character(10) :: fnm
!
! -------------------------------------------------------------------- /
! Initialize filter
!
      if (present(rc)) rc = ESMF_SUCCESS

      do l = -nsig,nsig
        do k = -nsig,nsig
          wflt(k,l) = exp( -half*( real(k,ESMF_KIND_RX)**2 &
                                 + real(l,ESMF_KIND_RX)**2 ) )
        enddo
      enddo
!
! -------------------------------------------------------------------- /
! Set up fields and pointers
!
      bmskField = ESMF_FieldCreate( impGrid, impArraySpec2D, &
        totalLWidth=impHaloLWidth, totalUWidth=impHaloUWidth, &
        staggerLoc=impStaggerLoc, indexFlag=impIndexFlag, &
        name='bmsk', rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return

      cmskField = ESMF_FieldCreate( impGrid, impArraySpec2D, &
        totalLWidth=impHaloLWidth, totalUWidth=impHaloUWidth, &
        staggerLoc=impStaggerLoc, indexFlag=impIndexFlag, &
        name='cmsk', rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return

      if ( impGridIsLocal ) then
        call ESMF_FieldGet( impMask, localDE=lde, farrayPtr=mptr, &
          exclusiveLBound=elb, exclusiveUBound=eub, &
          totalLBound=tlb, totalUBound=tub, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call ESMF_FieldGet( dstField,  localDE=lde, farrayPtr=dptr, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call ESMF_FieldGet( srcField,  localDE=lde, farrayPtr=sptr, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call ESMF_FieldGet( bmskField, localDE=lde, farrayPtr=bmsk, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call ESMF_FieldGet( cmskField, localDE=lde, farrayPtr=cmsk, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      endif
!
! -------------------------------------------------------------------- /
! Create blending mask
!
      if ( impGridIsLocal ) then
        do j = elb(2),eub(2)
          do i = elb(1),eub(1)
            if ( dptr(i,j).eq.missingVal ) then
              bmsk(i,j) = zero
            else
              bmsk(i,j) = one
            endif
            cmsk(i,j) = bmsk(i,j)
          enddo
        enddo
      endif
#if defined(TEST_WMESMFMD) || defined(TEST_WMESMFMD_BLENDIMPFIELDS)
      call ESMF_FieldGet( dstField, name=fnm, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_FieldWrite( bmskField, &
        "wmesmfmd_blendimpfields_"//trim(fnm)//"_bmsk.nc", &
        overwrite=.true., timeSlice=1, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
#endif

      iter_loop: do iter = 1,niter

        call ESMF_FieldHalo( bmskField, impHaloRH, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return

        if ( impGridIsLocal ) then

          j_loop: do j = elb(2),eub(2)
            i_loop: do i = elb(1),eub(1)
              if ( nint(mptr(i,j)).eq.maskValueLand ) cycle i_loop
              if ( dptr(i,j).eq.missingVal ) cycle i_loop

              bsum = zero
              wsum = zero
              l_loop: do l = -nsig,nsig
                jj = j + l
                if ( jj.lt.tlb(2).or.jj.gt.tub(2) ) cycle l_loop
                k_loop: do k = -nsig,nsig
                  ii = i + k
                  if ( ii.lt.tlb(1).or.ii.gt.tub(1) ) cycle k_loop
                  if ( nint(mptr(ii,jj)).eq.maskValueLand ) cycle k_loop
                  bsum = bsum + wflt(k,l)*bmsk(ii,jj)
                  wsum = wsum + wflt(k,l)
                enddo k_loop
              enddo l_loop
              cmsk(i,j) = bsum/wsum

            enddo i_loop
          enddo j_loop

          do j = elb(2),eub(2)
            do i = elb(1),eub(1)
              if ( nint(mptr(i,j)).eq.maskValueLand ) cycle
              bmsk(i,j) = cmsk(i,j)
            enddo
          enddo

        endif
#if defined(TEST_WMESMFMD) || defined(TEST_WMESMFMD_BLENDIMPFIELDS)
        call ESMF_FieldGet( dstField, name=fnm, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call ESMF_FieldWrite( bmskField, &
          "wmesmfmd_blendimpfields_"//trim(fnm)//"_bmsk.nc", &
          overwrite=.true., timeSlice=iter+1, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
#endif

      enddo iter_loop
!
! -------------------------------------------------------------------- /
! Blend Fields
!
      if ( impGridIsLocal ) then
        do j = elb(2),eub(2)
          do i = elb(1),eub(1)
            if ( nint(mptr(i,j)).eq.maskValueLand ) cycle
            dptr(i,j) = bmsk(i,j)*dptr(i,j) + (one-bmsk(i,j))*sptr(i,j)
          enddo
        enddo
      endif
!
! -------------------------------------------------------------------- /
! Clean up
!
      call ESMF_FieldDestroy( bmskField, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return

      call ESMF_FieldDestroy( cmskField, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!/
!/ End of BlendImpFields --------------------------------------------- /
!/
      end subroutine BlendImpFields
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "FieldFill"
      subroutine FieldFill(field, fillVal, maskVal, rc)
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         20-Jan-2017 |
!/                  +-----------------------------------+
!/
!/    20-Jan-2017 : Origination.                        ( version 6.02 )
!/
!  1. Purpose :
!
!     Fill ESMF Field
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      NONE
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_Field)                 :: field
      real(ESMF_KIND_RX)               :: fillVal
      integer(ESMF_KIND_I4), optional  :: maskVal(:)
      integer,               optional  :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      integer :: ldecnt, lde, i, j, k
      integer :: rank, iund
      integer :: lb1(1), ub1(1)
      integer :: lb2(2), ub2(2)
      integer :: lb3(3), ub3(3)
      integer :: gridToFieldMap(2)
      type(ESMF_Grid) :: grid
      type(ESMF_StaggerLoc) :: stgr
      type(ESMF_Array) :: maskArray
      integer(ESMF_KIND_I4), pointer :: mask(:,:)
      real(ESMF_KIND_RX), pointer :: dptr1(:)
      real(ESMF_KIND_RX), pointer :: dptr2(:,:)
      real(ESMF_KIND_RX), pointer :: dptr3(:,:,:)
!
! -------------------------------------------------------------------- /
! Fill Field
!
      if (present(rc)) rc = ESMF_SUCCESS

      call ESMF_FieldGet(field, localDECount=ldecnt, grid=grid, &
        staggerLoc=stgr, rank=rank, &
        gridToFieldMap=gridToFieldMap, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return ! bail out
      if (rank.ne.1.and.rank.ne.2.and.rank.ne.3) then
        call ESMF_LogSetError(ESMF_FAILURE, rcToReturn=rc, &
        msg='FieldFill: rank must be 1, 2 or 3')
        return ! bail out
      endif

      if (gridToFieldMap(1).eq.1.and.gridToFieldMap(2).eq.2) then
        iund = 3
      elseif (gridToFieldMap(1).eq.1.and.gridToFieldMap(2).eq.3) then
        iund = 2
      else
        iund = 1
      endif

      if (present(maskVal)) then
        if ( rank.eq.1 ) then
          call ESMF_LogSetError(ESMF_FAILURE, rcToReturn=rc, &
          msg='FieldFill: maskVal cannot be used with rank=1')
          return ! bail out
        endif
        call ESMF_GridGetItem(grid, itemFlag=ESMF_GRIDITEM_MASK, &
          staggerLoc=stgr, array=maskArray, rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return ! bail out
      endif

      do lde=0,ldecnt-1

        if (rank.eq.1) then
          call ESMF_FieldGet(field, localDE=lde, farrayPtr=dptr1, &
               exclusiveLBound=lb1, exclusiveUBound=ub1, rc=rc)
          if (ESMF_LogFoundError(rc, PASSTHRU)) return ! bail out
        elseif (rank.eq.2) then
          call ESMF_FieldGet(field, localDE=lde, farrayPtr=dptr2, &
               exclusiveLBound=lb2, exclusiveUBound=ub2, rc=rc)
          if (ESMF_LogFoundError(rc, PASSTHRU)) return ! bail out
        else
          call ESMF_FieldGet(field, localDE=lde, farrayPtr=dptr3, &
               exclusiveLBound=lb3, exclusiveUBound=ub3, rc=rc)
          if (ESMF_LogFoundError(rc, PASSTHRU)) return ! bail out
        endif

        if (present(maskVal)) then
          call ESMF_ArrayGet(maskArray, localDE=lde, farrayPtr=mask, rc=rc)
          if (ESMF_LogFoundError(rc, PASSTHRU)) return ! bail out
        endif

        if (rank.eq.1) then

          dptr1(lb1(1):ub1(1)) = fillVal

        elseif (rank.eq.2) then

          if (present(maskVal)) then
            do j = lb2(2),ub2(2)
            do i = lb2(1),ub2(1)
              if (all(mask(i,j).ne.maskVal)) dptr2(i,j) = fillVal
            enddo
            enddo
          else
            dptr2(lb2(1):ub2(1),lb2(2):ub2(2)) = fillVal
          endif

        else

          if (present(maskVal)) then
            select case (iund)
            case (1)
              do j = lb3(3),ub3(3)
              do i = lb3(2),ub3(2)
                if (all(mask(i,j).ne.maskVal)) &
                  dptr3(lb3(1):ub3(1),i,j) = fillVal
              enddo
              enddo
            case (2)
              do j = lb3(3),ub3(3)
              do i = lb3(1),ub3(1)
                if (all(mask(i,j).ne.maskVal)) &
                  dptr3(i,lb3(2):ub3(2),j) = fillVal
              enddo
              enddo
            case (3)
              do j = lb3(2),ub3(2)
              do i = lb3(1),ub3(1)
                if (all(mask(i,j).ne.maskVal)) &
                  dptr3(i,j,lb3(3):ub3(3)) = fillVal
              enddo
              enddo
            end select
          else
            dptr3(lb3(1):ub3(1),lb3(2):ub3(2),lb3(3):ub3(3)) = fillVal
          endif

        endif

      enddo
!/
!/ End of FieldFill ------------------------------------------------- /
!/
      end subroutine FieldFill
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "FieldGather"
      subroutine FieldGather(field, n1, n2, fout, rc)
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         20-Jan-2017 |
!/                  +-----------------------------------+
!/
!/    20-Jan-2017 : Origination.                        ( version 6.02 )
!/
!  1. Purpose :
!
!     All gather of ESMF field
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      NONE
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_Field)                 :: field
      integer                          :: n1, n2
      real                             :: fout(n1,n2)
      integer,               optional  :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      integer :: k
      real(ESMF_KIND_RX) :: floc(n1,n2)
!
! -------------------------------------------------------------------- /
! Gather Field
!
      if (present(rc)) rc = ESMF_SUCCESS

      do k = 0,npet-1
        call ESMF_FieldGather( field,  floc, rootPet=k, vm=vm, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      enddo
      fout(1:n1,1:n2) = floc(1:n1,1:n2)
!/
!/ End of FieldGather ------------------------------------------------ /
!/
      end subroutine FieldGather
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "FieldIndex"
      function FieldIndex ( fnameList, fname, rc ) result (indx)
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         20-Jan-2017 |
!/                  +-----------------------------------+
!/
!/    20-Jan-2017 : Origination.                        ( version 6.02 )
!/
!  1. Purpose :
!
!     Return index associated with field name
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       fnameList StrA   I   Array of field names
!       fname     Str    I   Field name
!       rc        Int.   O   Return code
!       indx      Int    I   Returned index of fname
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      NONE
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      character (6) :: fnameList(:)
      character (6) :: fname
      integer       :: rc
      integer       :: indx
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      integer       :: i, check
!
! -------------------------------------------------------------------- /
! Find name in fnameList that matches fname
!
      check = lbound(fnameList,1) - 1
      indx = check
      do i = lbound(fnameList,1),ubound(fnameList,1)
        if ( fnameList(i).eq.fname ) then
          indx = i
          exit
        endif
      enddo
      if ( indx.eq.check ) then
        call ESMF_LogSetError(ESMF_FAILURE, rcToReturn=rc, &
          msg='FieldIndex: input name ('//fname//') not in list')
      endif
!/
!/ End of FieldIndex ------------------------------------------------- /
!/
      end function FieldIndex
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "PrintTimers"
      subroutine PrintTimers ( cname, wtnam, wtcnt, wtime )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         20-Jan-2017 |
!/                  +-----------------------------------+
!/
!/    20-Jan-2017 : Origination.                        ( version 6.02 )
!/
!  1. Purpose :
!
!     Print wallclock timers to ESMF log file
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       cname     Str    I   Name of component
!       wtnam     Str    I   Timer names
!       wtcnt     Int    I   Timer counts
!       wtime     R8     I   Timers
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      NONE
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      character(*) :: cname
      character(*) :: wtnam(:)
      integer      :: wtcnt(:)
      real(8)      :: wtime(:)
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(128) :: msg
      integer :: k
!
! -------------------------------------------------------------------- /
! Print timers to ESMF log file
!
      write(msg,1) trim(cname),"timer","count","time"
      call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      do k=lbound(wtcnt,1),ubound(wtcnt,1)
        write(msg,2) trim(cname),trim(wtnam(k)),wtcnt(k),wtime(k)
        call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      enddo
!
! -------------------------------------------------------------------- /
! Formats
!
1     format(a,': wtime: ',a20,a10,a14)
2     format(a,': wtime: ',a20,i10,e14.6)
!/
!/ End of PrintTimers ------------------------------------------------ /
!/
      end subroutine PrintTimers
!/ ------------------------------------------------------------------- /
!/
!/ End of module WMESMFMD -------------------------------------------- /
!/
      end module WMESMFMD
