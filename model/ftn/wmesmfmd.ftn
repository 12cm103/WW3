#include "w3macros.h"
!/
!/ ------------------------------------------------------------------- /
!/ Macros for ESMF logging
!/
#define FILENAME "wmesmfmd.ftn"
#define CONTEXT  line=__LINE__,file=FILENAME,method=METHOD
#define PASSTHRU msg=ESMF_LOGERR_PASSTHRU,CONTEXT
!/
!/ ------------------------------------------------------------------- /
!/ Define real kind for data passed through ESMF interface
!/
#if defined(ESMF_R8)
#define ESMF_KIND_RX ESMF_KIND_R8
#define ESMF_TYPEKIND_RX ESMF_TYPEKIND_R8
#else
#define ESMF_KIND_RX ESMF_KIND_R4
#define ESMF_TYPEKIND_RX ESMF_TYPEKIND_R4
#endif
!/
!/ ------------------------------------------------------------------- /
      module WMESMFMD
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         DD-MMM-YYYY |
!/                  +-----------------------------------+
!/
!/    DD-MMM-YYYY : Origination.                        ( version 5.XX )
!/
!/    Copyright 2009-2014 National Weather Service (NWS),
!/       National Oceanic and Atmospheric Administration.  All rights
!/       reserved.  WAVEWATCH III is a trademark of the NWS. 
!/       No unauthorized use without permission.
!/
!  1. Purpose :
!
!     National Unified Prediction Capability (NUOPC) based
!     Earth System Modeling Framework (ESMF) interface module for
!     multi-grid wave model.
!
!  2. Variables and types :
!
!     All module variables and types are scoped private by default.
!     The private module variables and types are not listed in this section.
!
!      Name      Type  Scope    Description
!     ----------------------------------------------------------------
!     ----------------------------------------------------------------
!
!  3. Subroutines and functions :
!
!     All module subroutines and functions are scoped private by default.
!
!      Name            Type   Scope    Description
!     ----------------------------------------------------------------
!      SetServices     Subr.  Public   Wave model ESMF Set Services
!     ----------------------------------------------------------------
!      InitializeP0    Subr.  Private  Wave model NUOPC/ESMF Initialize phase 0
!      InitializeP1    Subr.  Private  Wave model NUOPC/ESMF Initialize phase 1
!      InitializeP3    Subr.  Private  Wave model NUOPC/ESMF Initialize phase 3
!      Finalize        Subr.  Private  Wave model NUOPC/ESMF Finalize
!      DataInitialize  Subr.  Private  Wave model NUOPC/ESMF Data Initialize
!      ModelAdvance    Subr.  Private  Wave model NUOPC/ESMF Model Advance
!      GetImport       Subr.  Private  Wave model get import fields
!      SetExport       Subr.  Private  Wave model set export fields
!      PrintTimers     Subr.  Private  Wave model print wallclock timers
!     ----------------------------------------------------------------
!
!  4. Subroutines and functions used :
!
!     See subroutine documentation.
!
!  5. Remarks :
!
!  6. Switches :
!
!  7. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ Use associated modules
!/
! --- ESMF Module
      use ESMF

! --- NUOPC modules
      use NUOPC
      use NUOPC_Model, parent_SetServices => SetServices

! --- WW3 modules
      use CONSTANTS
      use WMINITMD, only: WMINIT
      use WMWAVEMD, only: WMWAVE
      use WMFINLMD, only: WMFINL
      use WMMDATMD
      use W3GDATMD
      use W3IDATMD
      use W3ODATMD
      use W3WDATMD
      use W3TIMEMD
!/
!/ Specify default data typing
!/
      implicit none
!/
!/ Specify default accessibility
!/
      private
      save
!/
!/ Public module methods
!/
      public SetServices
!/
!/ Private module parameters
!/
! --- Default Mask Convention for import/export fields
      INTEGER, PARAMETER :: DEFAULT_MASK_WATER =  0
      INTEGER, PARAMETER :: DEFAULT_MASK_LAND  =  1

! --- Miscellaneous
      integer, parameter :: stdo = 6
      integer, parameter :: localDE = 0
      type(ESMF_VM) :: vm
      integer :: lpet, npet
      logical :: verbose
      logical :: realizeAllExport = .false.
      character(ESMF_MAXSTR) :: msg
!
! --- Timing
      integer, parameter :: numwt=8
      character(32) :: wtnam(numwt)
      integer       :: wtcnt(numwt)
      real(8)       :: wtime(numwt)
!
! --- Grid stuff
      type(ESMF_Grid)    :: grid2d
      integer            :: maskValueWater = DEFAULT_MASK_WATER
      integer            :: maskValueLand  = DEFAULT_MASK_LAND
      integer            :: nxproc, nyproc
      integer            :: ixlb, ixub, iylb, iyub
      integer            :: nz ! Number of z-levels for 3D fields
      logical            :: include3d
!
! --- Import Fields
      integer, parameter :: numImpFields = 6
      character(6)       :: impFieldName(numImpFields)
      character(128)     :: impFieldStdName(numImpFields)
      integer            :: impFieldDim(numImpFields)
      logical            :: initRqrdImpField(numImpFields)
      logical            :: isActiveImpField(numImpFields)
      logical            :: isVectorImpField(numImpFields)
      type(ESMF_Field)   :: impField(numImpFields)
!
! --- Background import Fields
      real(ESMF_KIND_RX) :: missingValue
      character(10)      :: mbgFieldName(numImpFields)
      character(128)     :: mbgFieldStdName(numImpFields)
      logical            :: isActiveMbgField(numImpFields)
      type(ESMF_Field)   :: mbgField(numImpFields)
!
! --- Export Fields
      integer, parameter :: numExpFields = 8
      character(6)       :: expFieldName(numExpFields)
      character(128)     :: expFieldStdName(numExpFields)
      integer            :: expFieldDim(numExpFields)
      logical            :: isActiveExpField(numExpFields)
      logical            :: isVectorExpField(numExpFields)
      type(ESMF_Field)   :: expField(numExpFields)
!/
!/ ------------------------------------------------------------------- /
      contains
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "SetServices"
      subroutine SetServices ( gcomp, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         DD-MMM-YYYY |
!/                  +-----------------------------------+
!/
!/    DD-MMM-YYYY : Origination.                        ( version 5.XX )
!/
!  1. Purpose :
!
!     Wave model ESMF set services.
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp   Type   I/O Gridded component
!       rc      Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name            Type   Module    Description
!     ----------------------------------------------------------------
!      InitializeP0    Subr.  WMESMFMD  Wave model NUOPC/ESMF Initialize phase 0
!      InitializeP1    Subr.  WMESMFMD  Wave model NUOPC/ESMF Initialize phase 1
!      InitializeP3    Subr.  WMESMFMD  Wave model NUOPC/ESMF Initialize phase 3
!      Finalize        Subr.  WMESMFMD  Wave model NUOPC/ESMF Finalize
!      DataInitialize  Subr.  WMESMFMD  Wave model NUOPC/ESMF Data Initialize
!      ModelAdvance    Subr.  WMESMFMD  Wave model NUOPC/ESMF Model Advance
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      !NONE
!
! -------------------------------------------------------------------- /
! Prep
!
! --- Set default return code
      rc = ESMF_FAILURE

! --- Initialize wallclock timers

      wtnam( 1) = 'InitializeP0'
      wtnam( 2) = 'InitializeP1'
      wtnam( 3) = 'InitializeP3'
      wtnam( 4) = 'DataInitialize'
      wtnam( 5) = 'ModelAdvance'
      wtnam( 6) = 'Finalize'
      wtnam( 7) = 'GetImport'
      wtnam( 8) = 'SetExport'
      wtcnt( :) = 0
      wtime( :) = 0d0
!
! -------------------------------------------------------------------- /
! 1.  NUOPC model component will register the generic methods
!
      call NUOPC_CompDerive(gcomp, parent_SetServices, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! 2.  Set model entry points
!
! --- Initialize - phase 0 (requires use of ESMF method)

      call ESMF_GridCompSetEntryPoint(gcomp, ESMF_METHOD_INITIALIZE, &
        userRoutine=InitializeP0, phase=0, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return

! --- Set entry points for initialize methods

      ! >= IPDv03 supports satisfying inter-model data dependencies and
      ! the transfer of ESMF Grid & Mesh objects between Model and/or
      ! Mediator components during initialization
      ! IPDv03p1: advertise import & export fields
      call NUOPC_CompSetEntryPoint(gcomp, ESMF_METHOD_INITIALIZE, &
        phaseLabelList=(/"IPDv03p1"/), userRoutine=InitializeP1, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      ! IPDv03p2: unspecified by NUOPC -- not required
      ! IPDv03p3: realize import & export fields
      call NUOPC_CompSetEntryPoint(gcomp, ESMF_METHOD_INITIALIZE, &
        phaseLabelList=(/"IPDv03p3"/), userRoutine=InitializeP3, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      ! IPDv03p4: relevant for TransferActionGeomObject=="accept"
      ! IPDv03p5: relevant for TransferActionGeomObject=="accept"
      ! IPDv03p6: check compatibility of fields connected status
      ! IPDv03p7: handle field data initialization

!
! -------------------------------------------------------------------- /
! 3.  Register specializing methods
!
! --- Model initialize export data method

      call NUOPC_CompSpecialize(gcomp, specLabel=label_DataInitialize, &
        specRoutine=DataInitialize, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return

! --- Model checkImport method (overriding default)

      call ESMF_MethodRemove(gcomp, label_CheckImport, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call NUOPC_CompSpecialize(gcomp, specLabel=label_CheckImport, &
        specRoutine=NUOPC_NoOp, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      
! --- Model advance method

      call NUOPC_CompSpecialize(gcomp, specLabel=label_Advance, &
        specRoutine=ModelAdvance, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return

! --- Model finalize method

      call NUOPC_CompSpecialize(gcomp, specLabel=label_Finalize, &
        specRoutine=Finalize, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! Post
!
      rc = ESMF_SUCCESS
!/
!/ End of SetServices ------------------------------------------------ /
!/
      end subroutine SetServices
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "InitializeP0"
      subroutine InitializeP0 ( gcomp, impState, expState, extClock, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         DD-MMM-YYYY |
!/                  +-----------------------------------+
!/
!/    DD-MMM-YYYY : Origination.                        ( version 5.XX )
!/
!  1. Purpose :
!
!     Initialize wave model (phase 0)
!     * Define the NUOPC Initialize Phase Mapping
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp     Type   I/O Gridded component
!       impState  Type   I/O Import state
!       expState  Type   I/O Export state
!       extClock  Type   I   External clock
!       rc        Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      NONE
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      type(ESMF_State)    :: impState
      type(ESMF_State)    :: expState
      type(ESMF_Clock)    :: extClock
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(ESMF_MAXSTR) :: cname
      character(ESMF_MAXSTR) :: verbosity
      integer, parameter :: iwt=1
      real(8) :: wstime, wftime
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_FAILURE
      call ESMF_VMWtime(wstime)
      call ESMF_GridCompGet(gcomp, name=cname, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return

! --- Determine verbosity

      call NUOPC_CompAttributeGet(gcomp, name='Verbosity', &
        value=verbosity, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (trim(verbosity)=="high") then
        verbose = .true.
      else
        verbose = .false.
      endif
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (verbose) call ESMF_LogWrite(trim(cname)// &
        ': entered InitializeP0', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! Define initialization phases
! * switch to IPDv03 by filtering all other phaseMap entries
!
      call NUOPC_CompFilterPhaseMap(gcomp, ESMF_METHOD_INITIALIZE, &
        acceptStringList=(/"IPDv03p"/), rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! Post
!
      rc = ESMF_SUCCESS
      call ESMF_VMWtime(wftime)
      wtime(iwt) = wtime(iwt) + wftime - wstime
      wtcnt(iwt) = wtcnt(iwt) + 1
      if (verbose) call ESMF_LogWrite(trim(cname)// &
        ': leaving InitializeP0', ESMF_LOGMSG_INFO)
!/
!/ End of InitializeP0 ----------------------------------------------- /
!/
      end subroutine InitializeP0
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "InitializeP1"
      subroutine InitializeP1 ( gcomp, impState, expState, extClock, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         DD-MMM-YYYY |
!/                  +-----------------------------------+
!/
!/    DD-MMM-YYYY : Origination.                        ( version 5.XX )
!/
!  1. Purpose :
!
!     Initialize wave model (phase 1)
!     * Advertise fields in import and export states.
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp     Type   I/O Gridded component
!       impState  Type   I/O Import state
!       expState  Type   I/O Export state
!       extClock  Type   I   External clock
!       rc        Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name            Type  Module   Description
!     ----------------------------------------------------------------
!      WMINIT          Subr. WMINITMD Wave model initialization
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!     ----------------------------------------------------------------
!      1.  Initialization necessary for driver
!        a General I/O: (implicit in WMMDATMD)
!        b MPI environment
!        c Identifying output to "screen" unit
!      2.  Initialization of all wave models / grids       ( WMINIT )
!      3.  Advertise import fields
!      4.  Advertise export fields
!     ----------------------------------------------------------------
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      type(ESMF_State)    :: impState
      type(ESMF_State)    :: expState
      type(ESMF_Clock)    :: extClock
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(ESMF_MAXSTR) :: cname
      integer, parameter :: iwt=2
      real(8) :: wstime, wftime
      integer :: idsi, idso, idss, idst, idse
      integer :: mpiComm = -99
      logical :: configIsPresent
      type(ESMF_Config) :: config
      character(ESMF_MAXSTR) :: wrkdir = '.'
      character(ESMF_MAXSTR) :: preamb = '.'
      character(ESMF_MAXSTR) :: ifname = 'ww3_multi.inp'
      logical :: lsep_ss = .false.
      logical :: lsep_st = .false.
      logical :: lsep_se = .false.
      character(ESMF_MAXSTR) :: attstr
      integer(ESMF_KIND_I4) :: yy,mm,dd,h,m,s
      type(ESMF_Time) :: ttmp
      type(ESMF_TimeInterval) :: tstep, etstep
      integer :: i, i1, i2, i3, j, n, imod
      logical :: includeObg, includeAbg, includeIbg
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_FAILURE
      call ESMF_VMWtime(wstime)
      call ESMF_GridCompGet(gcomp, name=cname, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (verbose) call ESMF_LogWrite(trim(cname)// &
        ': entered InitializeP1', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! 1.  Initialization necessary for driver
!
! 1.a Set global flag indicating that model is an ESMF Component
!
      is_esmf_component = .true.
!
!
! 1.b Get MPI environment from ESMF VM and set WW3 MPI related variables
!
      call ESMF_GridCompGet(gcomp, vm=vm, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_VMGet(vm, petCount=npet, localPet=lpet, &
        mpiCommunicator=mpiComm, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      nmproc = npet
      improc = lpet + 1
      nmpscr = 1
      if ( improc .eq. nmpscr ) write (*,900)
!
! 1.c Get background model info
!
#if defined(COAMPS)
      call ESMF_AttributeGet(gcomp, name="OcnBackground", &
        value=attstr, defaultValue="none", &
        convention="COAMPS", purpose="General", rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      includeObg = trim(attstr).eq."model"
      call ESMF_AttributeGet(gcomp, name="AtmBackground", &
        value=attstr, defaultValue="none", &
        convention="COAMPS", purpose="General", rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      includeAbg = trim(attstr).eq."model"
      call ESMF_AttributeGet(gcomp, name="IceBackground", &
        value=attstr, defaultValue="none", &
        convention="COAMPS", purpose="General", rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      includeIbg = trim(attstr).eq."model"
      call ESMF_AttributeGet(gcomp, name="MissingValue", &
        value=missingValue, defaultValue=real(0,ESMF_KIND_RX), &
        convention="COAMPS", purpose="General", rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
#else
      includeObg = .false.
      includeAbg = .false.
      includeIbg = .false.
      missingValue = real(0,ESMF_KIND_RX)
#endif
!
! 1.d Config input
!
      call ESMF_GridCompGet(gcomp, configIsPresent=configIsPresent, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (configIsPresent) then
        call ESMF_GridCompGet(gcomp, config=config, rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        ! working directory
        call ESMF_ConfigGetAttribute(config, wrkdir, &
          label=trim(cname)//'_work_dir:', default='.', rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        ! I/O options
        call ESMF_ConfigGetAttribute(config, ifname, &
          label=trim(cname)//'_input_file_name:', &
          default='ww3_multi.inp', rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call ESMF_ConfigGetAttribute(config, lsep_ss, &
          label=trim(cname)//'_stdo_output_to_file:', default=.false., rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call ESMF_ConfigGetAttribute(config, lsep_st, &
          label=trim(cname)//'_test_output_to_file:', default=.false., rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call ESMF_ConfigGetAttribute(config, lsep_se, &
          label=trim(cname)//'_error_output_to_file:', default=.false., rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        ! realize all export flag
        call ESMF_ConfigGetAttribute(config, realizeAllExport, &
          label=trim(cname)//'_realize_all_export:', default=.false., rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        ! grid mask convention
        call ESMF_ConfigGetAttribute(config, maskValueWater, &
          label='mask_value_water:', default=DEFAULT_MASK_WATER, rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call ESMF_ConfigGetAttribute(config, maskValueLand, &
          label='mask_value_land:', default=DEFAULT_MASK_LAND, rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      endif
!     preamb = trim(wrkdir)//'/'
      preamb = trim(preamb)//'/' !TODO: have separate paths for .inp, logs and data?
!
! 1.e Set internal start/stop time from external start/stop time
!
      call ESMF_ClockGet(extClock, startTime=ttmp, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_TimeGet(ttmp, yy=yy,mm=mm,dd=dd,h=h,m=m,s=s, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      stime(1) = 10000*yy + 100*mm + dd
      stime(2) = 10000*h  + 100*m  + s

      call ESMF_ClockGet(extClock, stopTime=ttmp, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_TimeGet(ttmp, yy=yy,mm=mm,dd=dd,h=h,m=m,s=s, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      etime(1) = 10000*yy + 100*mm + dd
      etime(2) = 10000*h  + 100*m  + s
!
! 1.f Identify available unit numbers
! Each ESMF_UtilIOUnitGet is followed by an OPEN statement for that
! unit so that subsequent ESMF_UtilIOUnitGet calls do not return the
! the same unit.  After getting all the available unit numbers, close
! the units since they will be opened within WMINIT.
!
      call ESMF_UtilIOUnitGet(idsi); open(unit=idsi, status='scratch');
      call ESMF_UtilIOUnitGet(idso); open(unit=idso, status='scratch');
      call ESMF_UtilIOUnitGet(idss); open(unit=idss, status='scratch');
      call ESMF_UtilIOUnitGet(idst); open(unit=idst, status='scratch');
      call ESMF_UtilIOUnitGet(idse); open(unit=idse, status='scratch');
      close(idsi); close(idso); close(idss); close(idst); close(idse);
!
! -------------------------------------------------------------------- /
! 2.  Initialization of all wave models / grids
!
! 2.a Call into WMINIT
!     
      if ( .not.lsep_ss ) idss = stdo
      if ( .not.lsep_st ) idst = stdo
      if ( .not.lsep_se ) idse = stdo
      call wminit ( idsi, idso, idss, idst, idse, trim(ifname), &
                    mpicomm, preamb=preamb )
!
! 2.b Check consistency between internal timestep and external
!     timestep (coupling interval)
!
      call ESMF_ClockGet(extClock, timeStep=etstep, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 2.c Create ESMF import/export grid
!
      call GridCreate(gcomp, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! 3.  Advertise import fields
!
! 3.a Initialize import field list
!
      imod = 1 !TODO: only work with grid 1 (for now)
      impFieldDim(:) = 2

      j = 1;  i1 = 1;  i2 = 1;
      isActiveImpField(i1:i2) = inpmap(imod,j).eq.-1
      impFieldName(i1)        = 'seahgt'
      impFieldStdName(i1)     = 'sea_surface_height_above_sea_level'
      initRqrdImpField(i1:i2) = .true.
      isActiveMbgField(i1:i2) = isActiveImpField(i1).and.includeObg

      j = 2;  i1 = 2;  i2 = 3;
      isActiveImpField(i1:i2) = inpmap(imod,j).eq.-1
      impFieldName(i1)        = 'uucurr'
      impFieldStdName(i1)     = 'surface_eastward_sea_water_velocity'
      impFieldName(i2)        = 'vvcurr'
      impFieldStdName(i2)     = 'surface_northward_sea_water_velocity'
      initRqrdImpField(i1:i2) = .true.
      isActiveMbgField(i1:i2) = isActiveImpField(i1).and.includeObg

      j = 3;  i1 = 4;  i2 = 5;
      isActiveImpField(i1:i2) = inpmap(imod,j).eq.-1
      impFieldName(i1)        = 'uutrue'
      impFieldStdName(i1)     = 'eastward_wind_at_10m_height'
      impFieldName(i2)        = 'vvtrue'
      impFieldStdName(i2)     = 'northward_wind_at_10m_height'
      initRqrdImpField(i1:i2) = .true.
      isActiveMbgField(i1:i2) = isActiveImpField(i1).and.includeAbg

      j = 4;  i1 = 6;  i2 = 6;
      isActiveImpField(i1:i2) = inpmap(imod,j).eq.-1
      impFieldName(i1)        = 'seaice'
      impFieldStdName(i1)     = 'sea_ice_concentration'
      initRqrdImpField(i1:i2) = .true.
      isActiveMbgField(i1:i2) = isActiveImpField(i1).and.includeIbg

      do i = 1,numImpFields
        mbgFieldName(i) = 'mbg_'//trim(impFieldName(i))
        mbgFieldStdName(i) = 'mbg_'//trim(impFieldStdName(i))
      enddo
!
! 3.b Advertise active import fields
!
      n = 0
      do i = 1,numImpFields
        if (.not.isActiveImpField(i)) cycle
        n = n + 1
        call NUOPC_Advertise(impState, &
          trim(impFieldStdName(i)), name=trim(impFieldName(i)), rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        if (.not.isActiveMbgField(i)) cycle
        n = n + 1
        call NUOPC_Advertise(impState, &
          trim(mbgFieldStdName(i)), name=trim(mbgFieldName(i)), rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      enddo
!
! 3.c Report advertised import fields
!
      write(msg,'(a,i0,a)') trim(cname)// &
        ': List of advertised import fields(',n,'):'
      call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      write(msg,'(a,a5,a,a10,a3,a)') trim(cname)// &
        ': ','index',' ','name',' ','standardName'
      call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      n = 0
      do i = 1,numImpFields
        if (.not.isActiveImpField(i)) cycle
        n = n + 1
        write(msg,'(a,i5,a,a10,a3,a)') trim(cname)//': ',n, &
          ' ',trim(impFieldName(i)),' ',trim(impFieldStdName(i))
        call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
        if (.not.isActiveMbgField(i)) cycle
        n = n + 1
        write(msg,'(a,i5,a,a10,a3,a)') trim(cname)//': ',n, &
          ' ',trim(mbgFieldName(i)),' ',trim(mbgFieldStdName(i))
        call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      enddo
!
! -------------------------------------------------------------------- /
! 4.  Advertise export fields
!
! 4.a Initialize export field list
!
      i1 = 1;  i2 = 2;  i3 = 2;
      expFieldName(i1)    = 'uscurr'
      expFieldStdName(i1) = 'eastward_stokes_drift_current'
      expFieldDim(i1)     = 3
      expFieldName(i2)    = 'vscurr'
      expFieldStdName(i2) = 'northward_stokes_drift_current'
      expFieldDim(i2)     = 3

      i1 = 3;  i2 = 4;  i3 = 5;
      expFieldName(i1)    = 'wbcuru'
      expFieldStdName(i1) = 'eastward_wave_bottom_current'
      expFieldDim(i1)     = 2
      expFieldName(i2)    = 'wbcurv'
      expFieldStdName(i2) = 'northward_wave_bottom_current'
      expFieldDim(i2)     = 2
      expFieldName(i3)    = 'wbcurf'
      expFieldStdName(i3) = 'wave_bottom_current_radian_frequency'
      expFieldDim(i3)     = 2

      i1 = 6;  i2 = 7;  i3 = 7;
      expFieldName(i1)    = 'wavsgu'
      expFieldStdName(i1) = 'eastward_wave_radiation_stress_gradient'
      expFieldDim(i1)     = 2
      expFieldName(i2)    = 'wavsgv'
      expFieldStdName(i2) = 'northward_wave_radiation_stress_gradient'
      expFieldDim(i2)     = 2

      i1 = 8;  i2 = 8;  i3 = 8;
      expFieldName(i1)    = 'charno'
      expFieldStdName(i1) = 'wave_induced_charnock_parameter'
      expFieldDim(i1)     = 2

      isActiveExpField(:) = .false.
!
! 4.b Advertise all export fields
!
      do i = 1,numExpFields
        call NUOPC_Advertise(expState, &
          trim(expFieldStdName(i)), name=trim(expFieldName(i)), rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      enddo
!
! 4.c Report advertised export fields
!
      write(msg,'(a,i0,a)') trim(cname)// &
        ': List of advertised export fields(',numExpFields,'):'
      call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      write(msg,'(a,a5,a,a10,a3,a)') trim(cname)// &
        ': ','index',' ','name',' ','standardName'
      call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      do i = 1,numExpFields
        write(msg,'(a,i5,a,a10,a3,a)') trim(cname)//': ',i, &
          ' ',trim(expFieldName(i)),' ',trim(expFieldStdName(i))
        call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      enddo
!
! -------------------------------------------------------------------- /
! Post
!
      rc = ESMF_SUCCESS
      call ESMF_VMWtime(wftime)
      wtime(iwt) = wtime(iwt) + wftime - wstime
      wtcnt(iwt) = wtcnt(iwt) + 1
      if (verbose) call ESMF_LogWrite(trim(cname)// &
        ': leaving InitializeP1', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! Formats
!
  900 format (/15x,'     *** WAVEWATCH III Multi-grid shell ***    '/ &
               15x,'================================================='/)
!/
!/ End of InitializeP1 ----------------------------------------------- /
!/
      end subroutine InitializeP1
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "InitializeP3"
      subroutine InitializeP3 ( gcomp, impState, expState, extClock, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         DD-MMM-YYYY |
!/                  +-----------------------------------+
!/
!/    DD-MMM-YYYY : Origination.                        ( version 5.XX )
!/
!  1. Purpose :
!
!     Initialize wave model (phase 3)
!     * Realize fields in import and export states.
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp     Type   I/O Gridded component
!       impState  Type   I/O Import state
!       expState  Type   I/O Export state
!       extClock  Type   I   External clock
!       rc        Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name            Type  Module   Description
!     ----------------------------------------------------------------
!      WMINIT          Subr. WMINITMD Wave model initialization
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      type(ESMF_State)    :: impState
      type(ESMF_State)    :: expState
      type(ESMF_Clock)    :: extClock
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(ESMF_MAXSTR) :: cname
      integer, parameter :: iwt=3
      real(8) :: wstime, wftime
      integer :: i, n
      logical :: isConnected
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_FAILURE
      call ESMF_VMWtime(wstime)
      call ESMF_GridCompGet(gcomp, name=cname, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (verbose) call ESMF_LogWrite(trim(cname)// &
        ': entered InitializeP3', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! 1.  Realize active import fields
!
! 1.a Create import fields and realize
!
      n = 0
      do i = 1,numImpFields
        if (.not.isActiveImpField(i)) cycle
        n = n + 1
        impField(i) = FieldCreate( impFieldName(i), impFieldDim(i), rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call NUOPC_Realize( impState, impField(i), rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        if (.not.isActiveMbgField(i)) cycle
        n = n + 1
        mbgField(i) = FieldCreate( mbgFieldName(i), impFieldDim(i), rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call NUOPC_Realize( impState, mbgField(i), rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      enddo
!
! 1.b Report realized import fields
!
      write(msg,'(a,i0,a)') trim(cname)// &
        ': List of realized import fields(',n,'):'
      call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      write(msg,'(a,a5,a,a10,a3,a)') trim(cname)// &
        ': ','index',' ','name',' ','standardName'
      call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      n = 0
      do i = 1,numImpFields
        if (.not.isActiveImpField(i)) cycle
        n = n + 1
        write(msg,'(a,i5,a,a10,a3,a)') trim(cname)//': ',n, &
          ' ',trim(impFieldName(i)),' ',trim(impFieldStdName(i))
        call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
        if (.not.isActiveMbgField(i)) cycle
        n = n + 1
        write(msg,'(a,i5,a,a10,a3,a)') trim(cname)//': ',n, &
          ' ',trim(mbgFieldName(i)),' ',trim(mbgFieldStdName(i))
        call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      enddo
!
! -------------------------------------------------------------------- /
! 2.  Realize active export fields
!
! 2.a Set connected export fields as active and remove unconnected
!     If realizeAllExport, then set all fields as active and realize.
!
      do i = 1,numExpFields
        isConnected = NUOPC_IsConnected(expState, &
                      expFieldName(i), rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        isActiveExpField(i) = isConnected .or. realizeAllExport
        if (.not.isActiveExpField(i)) then
          call ESMF_StateRemove(expState, (/expFieldName(i)/), rc=rc)
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
        endif
      enddo
!
! 2.b Create active export fields and realize
!
      n = 0
      do i = 1,numExpFields
        if (.not.isActiveExpField(i)) cycle
        n = n + 1
        expField(i) = FieldCreate( expFieldName(i), expFieldDim(i), rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call NUOPC_Realize( expState, expField(i), rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      enddo
!
! 2.c Report realized export fields
!
      write(msg,'(a,i0,a)') trim(cname)// &
        ': List of realized export fields(',n,'):'
      call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      write(msg,'(a,a5,a,a10,a3,a)') trim(cname)// &
        ': ','index',' ','name',' ','standardName'
      call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      n = 0
      do i = 1,numExpFields
        if (.not.isActiveExpField(i)) cycle
        n = n + 1
        write(msg,'(a,i5,a,a10,a3,a)') trim(cname)//': ',n, &
          ' ',trim(expFieldName(i)),' ',trim(expFieldStdName(i))
        call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      enddo
!
! -------------------------------------------------------------------- /
! Post
!
      rc = ESMF_SUCCESS
      call ESMF_VMWtime(wftime)
      wtime(iwt) = wtime(iwt) + wftime - wstime
      wtcnt(iwt) = wtcnt(iwt) + 1
      if (verbose) call ESMF_LogWrite(trim(cname)// &
        ': leaving InitializeP3', ESMF_LOGMSG_INFO)
!/
!/ End of InitializeP3 ----------------------------------------------- /
!/
      end subroutine InitializeP3
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "Finalize"
      subroutine Finalize ( gcomp, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         DD-MMM-YYYY |
!/                  +-----------------------------------+
!/
!/    DD-MMM-YYYY : Origination.                        ( version 5.XX )
!/
!  1. Purpose :
!
!     Finalize wave model
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp     Type   I/O Gridded component
!       rc        Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      WMFINL    Subr. WMFINLMD Wave model finalization
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(ESMF_MAXSTR) :: cname
      integer, parameter :: iwt=6
      real(8) :: wstime, wftime
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_FAILURE
      call ESMF_VMWtime(wstime)
      call ESMF_GridCompGet(gcomp, name=cname, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (verbose) call ESMF_LogWrite(trim(cname)// &
        ': entered Finalize', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! 1.  Finalize the wave model
!
      call wmfinl
!
! -------------------------------------------------------------------- /
! 2.  Clean up ESMF data structures
!
!TODO
!
! -------------------------------------------------------------------- /
! Post
!
      call ESMF_VMWtime(wftime)
      wtime(iwt) = wtime(iwt) + wftime - wstime
      wtcnt(iwt) = wtcnt(iwt) + 1
      call PrintTimers(trim(cname), wtnam, wtcnt, wtime)
      rc = ESMF_SUCCESS
      if ( improc .eq. nmpscr ) write (*,999)
      if (verbose) call ESMF_LogWrite(trim(cname)// &
        ': leaving Finalize', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! Formats
!
  999 format(//'  End of program '/                                   &
               ' ========================================'/           &
               '          WAVEWATCH III Multi-grid shell '/)
!/
!/ End of Finalize --------------------------------------------------- /
!/
      end subroutine Finalize
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "DataInitialize"
      subroutine DataInitialize ( gcomp, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         DD-MMM-YYYY |
!/                  +-----------------------------------+
!/
!/    DD-MMM-YYYY : Origination.                        ( version 5.XX )
!/
!  1. Purpose :
!
!     Initialize wave model export data
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp     Type   I/O Gridded component
!       rc        Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name            Type  Module   Description
!     ----------------------------------------------------------------
!      GetImport       Subr. WMESMFMD Wave model get import fields
!      SetExport       Subr. WMESMFMD Wave model set export fields
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(ESMF_MAXSTR) :: cname
      integer, parameter :: iwt=4
      real(8) :: wstime, wftime
      integer :: i
      logical :: fldUpdated, allUpdated
      type(ESMF_Clock) :: clock
      type(ESMF_Time) :: currTime
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_FAILURE
      call ESMF_VMWtime(wstime)
      call ESMF_GridCompGet(gcomp, name=cname, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (verbose) call ESMF_LogWrite(trim(cname)// &
        ': entered DataInitialize', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! 1.  Check that required import fields show correct time stamp
!
      call ESMF_GridCompGet(gcomp, clock=clock, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_ClockGet(clock, currTime=currTime, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return

      allUpdated = .true.
      do i = 1,numImpFields
        if (.not.isActiveImpField(i)) cycle
        if (initRqrdImpField(i)) then
          fldUpdated = NUOPC_IsAtTime(impField(i), currTime, rc=rc)
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
          if (fldUpdated) then
            write(msg,'(a,a10,a,a13)') trim(cname)//': ', &
              trim(impFieldName(i)),': inter-model data dependency: ', &
              'SATISFIED'
          else
            allUpdated = .false.
            write(msg,'(a,a10,a,a13)') trim(cname)//': ', &
              trim(impFieldName(i)),': inter-model data dependency: ', &
              'NOT SATISFIED'
          endif
        else
          write(msg,'(a,a10,a,a13)') trim(cname)//': ', &
            trim(impFieldName(i)),': inter-model data dependency: ', &
            'NOT  REQUIRED'
        endif
        if (verbose) call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
        if (improc.eq.nmpscr) write(*,'(a)') trim(msg)
        ! background
        if (.not.isActiveMbgField(i)) cycle
        if (initRqrdImpField(i)) then
          fldUpdated = NUOPC_IsAtTime(mbgField(i), currTime, rc=rc)
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
          if (fldUpdated) then
            write(msg,'(a,a10,a,a13)') trim(cname)//': ', &
              trim(mbgFieldName(i)),': inter-model data dependency: ', &
              'SATISFIED'
          else
            allUpdated = .false.
            write(msg,'(a,a10,a,a13)') trim(cname)//': ', &
              trim(mbgFieldName(i)),': inter-model data dependency: ', &
              'NOT SATISFIED'
          endif
        else
          write(msg,'(a,a10,a,a13)') trim(cname)//': ', &
            trim(mbgFieldName(i)),': inter-model data dependency: ', &
            'NOT  REQUIRED'
        endif
        if (verbose) call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
        if (improc.eq.nmpscr) write(*,'(a)') trim(msg)
      enddo
!
! If not all import dependencies are satisfied, then return
!
      if (.not.allUpdated) goto 1
!
! -------------------------------------------------------------------- /
! 2.  All import dependencies are satisfied, so finish initialization
!
! 2.a Report all import dependencies are satisfied
!
      write(msg,'(a)') trim(cname)// &
        ': all inter-model data dependencies SATISFIED'
      if (verbose) call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      if (improc.eq.nmpscr) write(*,'(a)') trim(msg)
!
! 2.b Get import fields
!
      call GetImport(gcomp, rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 2.c Finish initialization (compute initial state)
!
!     call wminit2(rc)
!     if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 2.d Set export fields
!
      call SetExport(gcomp, rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 2.e Set Updated Field Attribute to "true", indicating to the
!     generic code to set the timestamp for these fields
!
      do i = 1,numExpFields
        if (.not.isActiveExpField(i)) cycle
        call NUOPC_SetAttribute(expField(i), name="Updated", &
          value="true", rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      enddo
!
! 2.f Set InitializeDataComplete Attribute to "true", indicating to the
!     generic code that all inter-model data dependencies are satisfied
!
      call NUOPC_CompAttributeSet(gcomp, name="InitializeDataComplete", &
        value="true", rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! Post
!
1     rc = ESMF_SUCCESS
      call ESMF_VMWtime(wftime)
      wtime(iwt) = wtime(iwt) + wftime - wstime
      wtcnt(iwt) = wtcnt(iwt) + 1
      if (verbose) call ESMF_LogWrite(trim(cname)// &
        ': leaving DataInitialize', ESMF_LOGMSG_INFO)
!/
!/ End of DataInitialize --------------------------------------------- /
!/
      end subroutine DataInitialize
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "ModelAdvance"
      subroutine ModelAdvance ( gcomp, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         DD-MMM-YYYY |
!/                  +-----------------------------------+
!/
!/    DD-MMM-YYYY : Origination.                        ( version 5.XX )
!/
!  1. Purpose :
!
!     Advance wave model in time
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp     Type   I/O Gridded component
!       rc        Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      GetImport Subr. WMESMFMD Wave model get import fields
!      SetExport Subr. WMESMFMD Wave model set export fields
!      WMWAVE    Subr. WMWAVEMD Wave model run
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(ESMF_MAXSTR) :: cname
      integer, parameter :: iwt=5
      real(8) :: wstime, wftime
      integer :: stat, i, tcur(2)
      integer, allocatable :: tend(:,:)
      integer(ESMF_KIND_I4) :: yy,mm,dd,h,m,s
      type(ESMF_Clock) :: clock
      type(ESMF_Time) :: currTime, stopTime
      real :: delt
      logical :: lerr
      type(ESMF_State) :: state
      integer, save :: slice=1
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_FAILURE
      call ESMF_VMWtime(wstime)
      call ESMF_GridCompGet(gcomp, name=cname, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (verbose) call ESMF_LogWrite(trim(cname)// &
        ': entered ModelAdvance', ESMF_LOGMSG_INFO)

      allocate (tend(2,nrgrd), stat=rc)
      if (ESMF_LogFoundAllocError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! 1.  Advance model to requested end time
!
! 1.a Get component clock
!
      call ESMF_GridCompGet(gcomp, clock=clock, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 1.b Report
!
      if ( improc .eq. nmpscr ) then
        write(*,'(///)')
        call ESMF_ClockPrint(clock, options="currTime", &
          preString="-->Advancing "//TRIM(cname)//" from: ")
        call ESMF_ClockPrint(clock, options="stopTime", &
          preString="-----------------> to: ")
      endif
!
! 1.c Check internal current time with component current time
!
      call ESMF_ClockGet(clock, currTime=currTime, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_TimeGet(currTime, yy=yy,mm=mm,dd=dd,h=h,m=m,s=s, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      lerr=.false.
      do i = 1,nrgrd
        tcur(1) = 10000*yy + 100*mm + dd
        tcur(2) = 10000*h  + 100*m  + s
        call w3setw ( i, mdse, mdst )
        delt = dsec21 ( time, tcur )
        if ( abs(delt).gt.0 ) then
          lerr=.true.
          write(msg,'(a,i2,a,2(a,i8,a,i8,a))') &
            'Wave model grid ',i,': ', &
            'Internal time (',time(1),'.',time(2),') /= ', &
            'Component time (',tcur(1),'.',tcur(2),')'
          call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_ERROR)
        endif
      enddo
      if (lerr) then
        rc = ESMF_FAILURE
        return
      endif
!
! 1.d Set end time of this advance
!
      call ESMF_ClockGet(clock, stopTime=stopTime, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_TimeGet(stopTime, yy=yy,mm=mm,dd=dd,h=h,m=m,s=s, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      do i = 1,nrgrd
        tend(1,i) = 10000*yy + 100*mm + dd
        tend(2,i) = 10000*h  + 100*m  + s
      enddo
!
! 1.e Get import fields
!
      call GetImport(gcomp, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return

#if ! defined(COAMPS)
!     Dump import fields to file
      call NUOPC_ModelGet(gcomp, importState=state, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return

      call NUOPC_Write(state, fileNamePrefix="field_ww3_import_", &
        timeslice=slice, relaxedFlag=.true., rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      slice = slice + 1
#endif

!
! 1.f Advance model
!
      call wmwave ( tend )
!
! 1.g Set export fields
!
      call SetExport(gcomp, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! Post
!
      deallocate (tend, stat=rc)
      if (ESMF_LogFoundDeallocError(rc, PASSTHRU)) return
      rc = ESMF_SUCCESS
      call ESMF_VMWtime(wftime)
      wtime(iwt) = wtime(iwt) + wftime - wstime
      wtcnt(iwt) = wtcnt(iwt) + 1
      if (verbose) call ESMF_LogWrite(trim(cname)// &
        ': leaving ModelAdvance', ESMF_LOGMSG_INFO)
!/
!/ End of ModelAdvance ----------------------------------------------- /
!/
      end subroutine ModelAdvance
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "GetImport"
      subroutine GetImport ( gcomp, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         DD-MMM-YYYY |
!/                  +-----------------------------------+
!/
!/    DD-MMM-YYYY : Origination.                        ( version 5.XX )
!/
!  1. Purpose :
!
!     Get import fields and put in internal data structures
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp     Type   I/O Gridded component
!       rc        Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      NONE
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(ESMF_MAXSTR) :: cname
      integer, parameter :: iwt=7
      real(8) :: wstime, wftime
      integer :: i, i1, i2, i3, j, k, imod
      logical, save :: firstCall = .true.
      integer :: tcur(2), tend(2)
      integer(ESMF_KIND_I4) :: yy,mm,dd,h,m,s
      type(ESMF_Clock) :: clock
      type(ESMF_Time) :: currTime, stopTime
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_FAILURE
      call ESMF_VMWtime(wstime)
      call ESMF_GridCompGet(gcomp, name=cname, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (verbose) call ESMF_LogWrite(trim(cname)// &
        ': entered GetImport', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! 1.  Setup
!
! 1.a Set pointers for model grid
!
      imod = 1 !TODO: only work with grid 1 (for now)
      call w3setg ( imod, mdse, mdst )
      call w3setw ( imod, mdse, mdst )
      call w3seti ( imod, mdse, mdst )
      call wmsetm ( imod, mdse, mdst )
!
! 1.b Setup time stamps using currTime and stopTime
!
      call ESMF_GridCompGet(gcomp, clock=clock, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_ClockGet(clock, currTime=currTime, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_TimeGet(currTime, yy=yy,mm=mm,dd=dd,h=h,m=m,s=s, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      tcur(1) = 10000*yy + 100*mm + dd
      tcur(2) = 10000*h  + 100*m  + s
      call ESMF_ClockGet(clock, stopTime=stopTime, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_TimeGet(stopTime, yy=yy,mm=mm,dd=dd,h=h,m=m,s=s, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      tend(1) = 10000*yy + 100*mm + dd
      tend(2) = 10000*h  + 100*m  + s
!
! -------------------------------------------------------------------- /
! 2.  Water levels
!
      j = 1
      i1 = FieldIndex( impFieldName, 'seahgt', rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      i2 = i1
      if ( inpmap(imod,j).eq.-1 .and. isActiveImpField(i1) ) then
        if (firstCall) then
          tln = tcur
        else
          tln = tend
        endif
        tfn(:,j) = tln
        if ( isActiveMbgField(i1) ) then
          call FieldCopy( impField(i1), mbgField(i1), missingVal=missingValue, rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
        endif
        call FieldGather( impField(i1), nx, ny, wlev, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      endif
!
! -------------------------------------------------------------------- /
! 3.  Currents
!
      j = 2
      i1 = FieldIndex( impFieldName, 'uucurr', rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      i2 = FieldIndex( impFieldName, 'vvcurr', rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if ( inpmap(imod,j).eq.-1 .and. isActiveImpField(i1) ) then
        if (.not.firstCall) then
          tc0 = tcn
          cx0 = cxn
          cy0 = cyn
        endif
        if (firstCall) then
          tcn = tcur
        else
          tcn = tend
        endif
        tfn(:,j) = tcn
        if ( isActiveMbgField(i1) ) then
          call FieldCopy( impField(i1), mbgField(i1), missingVal=missingValue, rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
          call FieldCopy( impField(i2), mbgField(i2), missingVal=missingValue, rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
        endif
        call FieldGather( impField(i1), nx, ny, cxn, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call FieldGather( impField(i2), nx, ny, cyn, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        if (firstCall) then
          tc0 = tcn
          cx0 = cxn
          cy0 = cyn
        endif
      endif
!
! -------------------------------------------------------------------- /
! 4.  Winds
!
      j = 3
      i1 = FieldIndex( impFieldName, 'uutrue', rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      i2 = FieldIndex( impFieldName, 'vvtrue', rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if ( inpmap(imod,j).eq.-1 .and. isActiveImpField(i1) ) then
        if (.not.firstCall) then
          tw0 = twn
          wx0 = wxn
          wy0 = wyn
        endif
        if (firstCall) then
          twn = tcur
        else
          twn = tend
        endif
        tfn(:,j) = twn
        if ( isActiveMbgField(i1) ) then
          call FieldCopy( impField(i1), mbgField(i1), missingVal=missingValue, rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
          call FieldCopy( impField(i2), mbgField(i2), missingVal=missingValue, rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
        endif
        call FieldGather( impField(i1), nx, ny, wxn, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call FieldGather( impField(i2), nx, ny, wyn, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        if (firstCall) then
          tw0 = twn
          wx0 = wxn
          wy0 = wyn
        endif
      endif
!
! -------------------------------------------------------------------- /
! 5.  Sea ice concentration
!
      j = 4
      i1 = FieldIndex( impFieldName, 'seaice', rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      i2 = i1
      if ( inpmap(imod,j).eq.-1 .and. isActiveImpField(i1) ) then
        if (firstCall) then
          tin = tcur
        else
          tin = tend
        endif
        tfn(:,j) = tin
        if ( isActiveMbgField(i1) ) then
          call FieldCopy( impField(i1), mbgField(i1), missingVal=missingValue, rc=rc )
          if (ESMF_LogFoundError(rc, PASSTHRU)) return
        endif
        call FieldGather( impField(i1), nx, ny, icei, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      endif
!
! -------------------------------------------------------------------- /
! 5.  Clean up
!
      firstCall = .false.
!
! -------------------------------------------------------------------- /
! Post
!
      rc = ESMF_SUCCESS
      call ESMF_VMWtime(wftime)
      wtime(iwt) = wtime(iwt) + wftime - wstime
      wtcnt(iwt) = wtcnt(iwt) + 1
      if (verbose) call ESMF_LogWrite(trim(cname)// &
        ': leaving GetImport', ESMF_LOGMSG_INFO)
!/
!/ End of GetImport -------------------------------------------------- /
!/
      end subroutine GetImport
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "SetExport"
      subroutine SetExport ( gcomp, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         DD-MMM-YYYY |
!/                  +-----------------------------------+
!/
!/    DD-MMM-YYYY : Origination.                        ( version 5.XX )
!/
!  1. Purpose :
!
!     Set export fields from internal data structures
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp     Type   I/O Gridded component
!       rc        Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      NONE
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(ESMF_MAXSTR) :: cname
      integer, parameter :: iwt=8
      real(8) :: wstime, wftime
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_FAILURE
      call ESMF_VMWtime(wstime)
      call ESMF_GridCompGet(gcomp, name=cname, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (verbose) call ESMF_LogWrite(trim(cname)// &
        ': entered SetExport', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! Insert sections here
!

!
! -------------------------------------------------------------------- /
! Post
!
      rc = ESMF_SUCCESS
      call ESMF_VMWtime(wftime)
      wtime(iwt) = wtime(iwt) + wftime - wstime
      wtcnt(iwt) = wtcnt(iwt) + 1
      if (verbose) call ESMF_LogWrite(trim(cname)// &
        ': leaving SetExport', ESMF_LOGMSG_INFO)
!/
!/ End of SetExport -------------------------------------------------- /
!/
      end subroutine SetExport
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "GridCreate"
      subroutine GridCreate ( gcomp, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         DD-MMM-YYYY |
!/                  +-----------------------------------+
!/
!/    DD-MMM-YYYY : Origination.                        ( version 5.XX )
!/
!  1. Purpose :
!
!     Create ESMF import/export grids
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp     Type   I/O Gridded component
!       rc        Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      NONE
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(ESMF_MAXSTR) :: cname
      integer :: n, nfac, irp, imod
      real    :: gr, rp, pr, diff
      integer :: ix, iy
      integer :: elb(2), eub(2)
      integer(ESMF_KIND_I4), pointer :: iptr(:,:)
      real(ESMF_KIND_RX), pointer :: rptrx(:,:), rptry(:,:)
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_FAILURE
      call ESMF_GridCompGet(gcomp, name=cname, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (verbose) call ESMF_LogWrite(trim(cname)// &
        ': entered GridCreate', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! 1.  Create ESMF grid with 2D subdomain layout
!
! 1.a Set pointers for model grid
!
      imod = 1 !TODO: only work with grid 1 (for now)
      call w3setg ( imod, mdse, mdst )
      call w3setw ( imod, mdse, mdst )
      call w3seti ( imod, mdse, mdst )
      call wmsetm ( imod, mdse, mdst )
!
! 1.b Compute a 2D subdomain layout
!
      if ( nx.gt.ny ) then
        gr = sqrt(real(nx)/real(ny))
      else
        gr = sqrt(real(ny)/real(nx))
      endif
      irp = int(sqrt(real(nmproc)))
      diff = huge(gr)
      nfac = nmproc
      do n = irp,nmproc
        if ( mod(nmproc,n).ne.0 ) cycle
        pr = real(n**2)/real(nmproc)
        if ( abs(gr-pr) < diff ) then
          diff = abs(gr-pr)
          nfac = n
        endif
      enddo
      if ( nx.gt.ny ) then
        nxproc = nfac
        nyproc = nmproc/nfac
      else
        nxproc = nmproc/nfac
        nyproc = nfac
      endif
!
! 1.c Create ESMF import/export grid
!
      grid2d = ESMF_GridCreateNoPeriDim( &
        name=trim(cname)//"_grid", &
        coordTypeKind=ESMF_TYPEKIND_RX, regDecomp=(/nxproc,nyproc/), &
        decompFlag=(/ESMF_DECOMP_BALANCED,ESMF_DECOMP_BALANCED/), &
        minIndex=(/1,1/), maxIndex=(/nx,ny/), &
        coordDep1=(/1,2/), coordDep2=(/1,2/), &
        coordSys=ESMF_COORDSYS_SPH_DEG, &
        indexFlag=ESMF_INDEX_GLOBAL, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! 1.d Add coordinate arrays and land/sea mask to ESMF grid
!
      call ESMF_GridAddCoord( grid2d, &
        staggerLoc=ESMF_STAGGERLOC_CENTER, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_GridAddItem( grid2d, ESMF_GRIDITEM_MASK, &
        staggerLoc=ESMF_STAGGERLOC_CENTER, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
!
! -------------------------------------------------------------------- /
! 2.  Set grid coordinates and land/sea mask
!
! 2.a Exclusive bounds (global index)
!
      call ESMF_GridGet( grid2d, ESMF_STAGGERLOC_CENTER, localDE, &
        exclusiveLBound=elb, exclusiveUBound=eub, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      ixlb=elb(1);  ixub=eub(1);  iylb=elb(2);  iyub=eub(2);
!
! 2.b Set ESMF grid coordinate
!
      call ESMF_GridGetCoord( grid2d, 1, localDE=localDE, &
        staggerLoc=ESMF_STAGGERLOC_CENTER, farrayPtr=rptrx, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      call ESMF_GridGetCoord( grid2d, 2, localDE=localDE, &
        staggerLoc=ESMF_STAGGERLOC_CENTER, farrayPtr=rptry, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      do iy = iylb,iyub
        do ix = ixlb,ixub
          rptrx(ix,iy) = xgrd(iy,ix)
          rptry(ix,iy) = ygrd(iy,ix)
        enddo
      enddo
!
! 2.c Set ESMF land/sea mask values.
!     Land/sea mask is fixed in time and based on excluded points only.
!
      call ESMF_GridGetItem( grid2d, ESMF_GRIDITEM_MASK, localDE=localDE, &
        staggerLoc=ESMF_STAGGERLOC_CENTER, farrayPtr=iptr, rc=rc )
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      do iy = iylb,iyub
        do ix = ixlb,ixub
          if ( mapsta(iy,ix).ne.0 ) then
            iptr(ix,iy) = maskValueWater
          else
            iptr(ix,iy) = maskValueLand
          endif
        enddo
      enddo
!
! -------------------------------------------------------------------- /
! Post
!
      rc = ESMF_SUCCESS
      if (verbose) call ESMF_LogWrite(trim(cname)// &
        ': leaving GridCreate', ESMF_LOGMSG_INFO)
!/
!/ End of GridCreate ------------------------------------------------- /
!/
      end subroutine GridCreate
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "FieldCreate"
      function FieldCreate ( fname, nd, rc ) result(field)
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         DD-MMM-YYYY |
!/                  +-----------------------------------+
!/
!/    DD-MMM-YYYY : Origination.                        ( version 5.XX )
!/
!  1. Purpose :
!
!     Function to create ESMF field.
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       fname     Str.   Name of field
!       nd        Int.   Number of dimensions
!       rc        Int.   O   Return code
!       field     Type   ESMF_Field
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      NONE
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      character(*)        :: fname
      integer             :: nd
      integer,intent(out) :: rc
      type(ESMF_Field)    :: field
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      type(ESMF_ArraySpec) :: arraySpec
      real(ESMF_KIND_RX), pointer :: rptr2d(:,:), rptr3d(:,:,:)
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_FAILURE
!
! -------------------------------------------------------------------- /
! Create ESMF Field
!
      select case (nd)
      case (2)
        call ESMF_ArraySpecSet( arraySpec, rank=2, &
          typekind=ESMF_TYPEKIND_RX, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        field = ESMF_FieldCreate( grid2d, arraySpec, &
          indexFlag=ESMF_INDEX_GLOBAL, staggerLoc=ESMF_STAGGERLOC_CENTER, &
          name=trim(fname), rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call ESMF_FieldGet( field, farrayPtr=rptr2d, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        rptr2d = 0.0
      case (3)
        call ESMF_ArraySpecSet( arraySpec, rank=3, &
          typekind=ESMF_TYPEKIND_RX, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        field = ESMF_FieldCreate( grid2d, arraySpec, &
          indexFlag=ESMF_INDEX_GLOBAL, staggerLoc=ESMF_STAGGERLOC_CENTER, &
          ungriddedLBound=(/1/), ungriddedUBound=(/nz/), &
          name=trim(fname), rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        call ESMF_FieldGet( field, farrayPtr=rptr3d, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
        rptr3d = 0.0
      case default
        write (msg,'(a,i3)') 'Unsupported field dimension: '//trim(fname),nd
        call ESMF_LogWrite( trim(msg), ESMF_LOGMSG_ERROR )
        rc = ESMF_FAILURE
        return
      endselect
!
! -------------------------------------------------------------------- /
! Post
!
      rc = ESMF_SUCCESS
!/
!/ End of FieldCreate ------------------------------------------------ /
!/
      end function FieldCreate
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "PrintTimers"
      subroutine PrintTimers ( cname, wtnam, wtcnt, wtime )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         DD-MMM-YYYY |
!/                  +-----------------------------------+
!/
!/    DD-MMM-YYYY : Origination.                        ( version 5.XX )
!/
!  1. Purpose :
!
!     Print wallclock timers to ESMF log file
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       cname     Str    I   Name of component
!       wtnam     Str    I   Timer names
!       wtcnt     Int    I   Timer counts
!       wtime     R8     I   Timers
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      NONE
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      character(*) :: cname
      character(*) :: wtnam(:)
      integer      :: wtcnt(:)
      real(8)      :: wtime(:)
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(128) :: msg
      integer :: k
!
! -------------------------------------------------------------------- /
! Print timers to ESMF log file
!
      write(msg,1) trim(cname),"timer","count","time"
      call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      do k=lbound(wtcnt,1),ubound(wtcnt,1)
        write(msg,2) trim(cname),trim(wtnam(k)),wtcnt(k),wtime(k)
        call ESMF_LogWrite(trim(msg), ESMF_LOGMSG_INFO)
      enddo
!
! -------------------------------------------------------------------- /
! Formats
!
1     format(a,': wtime: ',a20,a10,a14)
2     format(a,': wtime: ',a20,i10,e14.6)
!/
!/ End of PrintTimers ------------------------------------------------ /
!/
      end subroutine PrintTimers
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "FieldIndex"
      function FieldIndex ( fnameList, fname, rc ) result (indx)
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         DD-MMM-YYYY |
!/                  +-----------------------------------+
!/
!/    DD-MMM-YYYY : Origination.                        ( version 5.XX )
!/
!  1. Purpose :
!
!     Return index associated with field name
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       fnameList StrA   I   Array of field names
!       fname     Str    I   Field name
!       rc        Int.   O   Return code
!       indx      Int    I   Returned index of fname
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      NONE
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      character (6) :: fnameList(:)
      character (6) :: fname
      integer       :: rc
      integer       :: indx
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      integer       :: i, check
!
! -------------------------------------------------------------------- /
! Find name in fnameList that matches fname
!
      check = lbound(fnameList,1) - 1
      indx = check
      do i = lbound(fnameList,1),ubound(fnameList,1)
        if ( fnameList(i).eq.fname ) then
          indx = i
          exit
        endif
      enddo
      if ( indx.eq.check ) then
        call ESMF_LogSetError(ESMF_FAILURE, rcToReturn=rc, &
          msg='FieldIndex: input name ('//fname//') not in list')
      endif
!/
!/ End of FieldIndex ------------------------------------------------- /
!/
      end function FieldIndex
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "FieldCopy"
      subroutine FieldCopy(dstField, srcField, dstMaskVal, srcMaskVal, missingVal, rc)
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         DD-MMM-YYYY |
!/                  +-----------------------------------+
!/
!/    DD-MMM-YYYY : Origination.                        ( version 5.XX )
!/
!  1. Purpose :
!
!     Copy ESMF Field
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      NONE
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
        type(ESMF_Field)                 :: dstField
        type(ESMF_Field)                 :: srcField
        integer(ESMF_KIND_I4), optional  :: dstMaskVal(:)
        integer(ESMF_KIND_I4), optional  :: srcMaskVal(:)
        real(ESMF_KIND_RX),    optional  :: missingVal
        integer,               optional  :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
        integer :: ldecnt, lde, i, j, k
        integer :: srcDimCount, dstDimCount, ndim, iund
        integer :: lb2(2), ub2(2)
        integer :: lb3(3), ub3(3)
        integer :: srcGridToFieldMap(2), dstGridToFieldMap(2)
        type(ESMF_Grid) :: srcGrid, dstGrid
        type(ESMF_StaggerLoc) :: srcStgr, dstStgr
        type(ESMF_Array) :: srcMaskArray, dstMaskArray
        integer(ESMF_KIND_I4), pointer :: srcMask(:,:), dstMask(:,:)
        real(ESMF_KIND_RX), pointer :: sptr2(:,:),   dptr2(:,:)
        real(ESMF_KIND_RX), pointer :: sptr3(:,:,:), dptr3(:,:,:)
!
! -------------------------------------------------------------------- /
! Copy Field
!
        if (present(rc)) rc = ESMF_SUCCESS

        if (present(missingVal)) then
          if (present(srcMaskVal).or.present(dstMaskVal)) then
            call ESMF_LogSetError(ESMF_FAILURE, rcToReturn=rc, &
            msg='FieldCopy: missingVal specified with srcMaskVal '// &
              'or dstMaskVal not supported')
            return ! bail out
          endif
        endif

        call ESMF_FieldGet(srcField, localDECount=ldecnt, grid=srcGrid, &
          staggerLoc=srcStgr, dimCount=srcDimCount, &
          gridToFieldMap=srcGridToFieldMap, rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return ! bail out
        if (srcDimCount.ne.2.and.srcDimCount.ne.3) then
          call ESMF_LogSetError(ESMF_FAILURE, rcToReturn=rc, &
          msg='FieldCopy: src dimCount must be 2 or 3')
          return ! bail out
        endif

        call ESMF_FieldGet(dstField, localDECount=ldecnt, grid=dstGrid, &
          staggerLoc=dstStgr, dimCount=dstDimCount, &
          gridToFieldMap=dstGridToFieldMap, rc=rc)
        if (ESMF_LogFoundError(rc, PASSTHRU)) return ! bail out
        if (dstDimCount.ne.2.and.dstDimCount.ne.3) then
          call ESMF_LogSetError(ESMF_FAILURE, rcToReturn=rc, &
          msg='FieldCopy: dst dimCount must be 2 or 3')
          return ! bail out
        endif

        if (srcDimCount.ne.dstDimCount) then
          call ESMF_LogSetError(ESMF_FAILURE, rcToReturn=rc, &
          msg='FieldCopy: src & dst dimCount must be equal')
          return ! bail out
        endif
        ndim = dstDimCount

        if (any(srcGridToFieldMap.ne.dstGridToFieldMap)) then
          call ESMF_LogSetError(ESMF_FAILURE, rcToReturn=rc, &
          msg='FieldCopy: src & dst gridToFieldMap must be equal')
          return ! bail out
        endif
        if (dstGridToFieldMap(1).eq.1.and.dstGridToFieldMap(2).eq.2) then
          iund = 3
        elseif (dstGridToFieldMap(1).eq.1.and.dstGridToFieldMap(2).eq.3) then
          iund = 2
        else
          iund = 1
        endif

        if (present(srcMaskVal)) then
          call ESMF_GridGetItem(srcGrid, itemFlag=ESMF_GRIDITEM_MASK, &
            staggerLoc=srcStgr, array=srcMaskArray, rc=rc)
          if (ESMF_LogFoundError(rc, PASSTHRU)) return ! bail out
        endif

        if (present(dstMaskVal)) then
          call ESMF_GridGetItem(dstGrid, itemFlag=ESMF_GRIDITEM_MASK, &
            staggerLoc=dstStgr, array=dstMaskArray, rc=rc)
          if (ESMF_LogFoundError(rc, PASSTHRU)) return ! bail out
        endif

        do lde=0,ldecnt-1

          if (ndim.eq.2) then
            call ESMF_FieldGet(srcField, localDE=lde, farrayPtr=sptr2, rc=rc)
            if (ESMF_LogFoundError(rc, PASSTHRU)) return ! bail out
            call ESMF_FieldGet(dstField, localDE=lde, farrayPtr=dptr2, &
                 exclusiveLBound=lb2, exclusiveUBound=ub2, rc=rc)
            if (ESMF_LogFoundError(rc, PASSTHRU)) return ! bail out
          else
            call ESMF_FieldGet(srcField, localDE=lde, farrayPtr=sptr3, rc=rc)
            if (ESMF_LogFoundError(rc, PASSTHRU)) return ! bail out
            call ESMF_FieldGet(dstField, localDE=lde, farrayPtr=dptr3, &
                 exclusiveLBound=lb3, exclusiveUBound=ub3, rc=rc)
            if (ESMF_LogFoundError(rc, PASSTHRU)) return ! bail out
          endif

          if (present(srcMaskVal)) then
            call ESMF_ArrayGet(srcMaskArray, localDE=lde, farrayPtr=srcMask, rc=rc)
            if (ESMF_LogFoundError(rc, PASSTHRU)) return ! bail out
          endif
          if (present(dstMaskVal)) then
            call ESMF_ArrayGet(dstMaskArray, localDE=lde, farrayPtr=dstMask, rc=rc)
            if (ESMF_LogFoundError(rc, PASSTHRU)) return ! bail out
          endif

          if (ndim.eq.2) then

            if (present(srcMaskVal).and.present(dstMaskVal)) then
              do j = lb2(2),ub2(2)
              do i = lb2(1),ub2(1)
                if (all(srcMask(i,j).ne.srcMaskVal).and. &
                    all(dstMask(i,j).ne.dstMaskVal)) dptr2(i,j) = sptr2(i,j)
              enddo
              enddo
            elseif (present(srcMaskVal)) then
              do j = lb2(2),ub2(2)
              do i = lb2(1),ub2(1)
                if (all(srcMask(i,j).ne.srcMaskVal)) dptr2(i,j) = sptr2(i,j)
              enddo
              enddo
            elseif (present(dstMaskVal)) then
              do j = lb2(2),ub2(2)
              do i = lb2(1),ub2(1)
                if (all(dstMask(i,j).ne.dstMaskVal)) dptr2(i,j) = sptr2(i,j)
              enddo
              enddo
            else
              if (present(missingVal)) then
                do j = lb2(2),ub2(2)
                do i = lb2(1),ub2(1)
                  if (dptr2(i,j).eq.missingVal) dptr2(i,j) = sptr2(i,j)
                enddo
                enddo
              else
                dptr2(lb2(1):ub2(1),lb2(2):ub2(2)) = &
                  sptr2(lb2(1):ub2(1),lb2(2):ub2(2))
              endif
            endif

          else

            if (present(srcMaskVal).and.present(dstMaskVal)) then
              select case (iund)
              case (1)
                do j = lb3(3),ub3(3)
                do i = lb3(2),ub3(2)
                  if (all(srcMask(i,j).ne.srcMaskVal).and. &
                      all(dstMask(i,j).ne.dstMaskVal)) &
                    dptr3(lb3(1):ub3(1),i,j) = sptr3(lb3(1):ub3(1),i,j)
                enddo
                enddo
              case (2)
                do j = lb3(3),ub3(3)
                do i = lb3(1),ub3(1)
                  if (all(srcMask(i,j).ne.srcMaskVal).and. &
                      all(dstMask(i,j).ne.dstMaskVal)) &
                    dptr3(i,lb3(2):ub3(2),j) = sptr3(i,lb3(2):ub3(2),j)
                enddo
                enddo
              case (3)
                do j = lb3(2),ub3(2)
                do i = lb3(1),ub3(1)
                  if (all(srcMask(i,j).ne.srcMaskVal).and. &
                      all(dstMask(i,j).ne.dstMaskVal)) &
                    dptr3(i,j,lb3(3):ub3(3)) = sptr3(i,j,lb3(3):ub3(3))
                enddo
                enddo
              end select
            elseif (present(srcMaskVal)) then
              select case (iund)
              case (1)
                do j = lb3(3),ub3(3)
                do i = lb3(2),ub3(2)
                  if (all(srcMask(i,j).ne.srcMaskVal)) &
                    dptr3(lb3(1):ub3(1),i,j) = sptr3(lb3(1):ub3(1),i,j)
                enddo
                enddo
              case (2)
                do j = lb3(3),ub3(3)
                do i = lb3(1),ub3(1)
                  if (all(srcMask(i,j).ne.srcMaskVal)) &
                    dptr3(i,lb3(2):ub3(2),j) = sptr3(i,lb3(2):ub3(2),j)
                enddo
                enddo
              case (3)
                do j = lb3(2),ub3(2)
                do i = lb3(1),ub3(1)
                  if (all(srcMask(i,j).ne.srcMaskVal)) &
                    dptr3(i,j,lb3(3):ub3(3)) = sptr3(i,j,lb3(3):ub3(3))
                enddo
                enddo
              end select
            elseif (present(dstMaskVal)) then
              select case (iund)
              case (1)
                do j = lb3(3),ub3(3)
                do i = lb3(2),ub3(2)
                  if (all(dstMask(i,j).ne.dstMaskVal)) &
                    dptr3(lb3(1):ub3(1),i,j) = sptr3(lb3(1):ub3(1),i,j)
                enddo
                enddo
              case (2)
                do j = lb3(3),ub3(3)
                do i = lb3(1),ub3(1)
                  if (all(dstMask(i,j).ne.dstMaskVal)) &
                    dptr3(i,lb3(2):ub3(2),j) = sptr3(i,lb3(2):ub3(2),j)
                enddo
                enddo
              case (3)
                do j = lb3(2),ub3(2)
                do i = lb3(1),ub3(1)
                  if (all(dstMask(i,j).ne.dstMaskVal)) &
                    dptr3(i,j,lb3(3):ub3(3)) = sptr3(i,j,lb3(3):ub3(3))
                enddo
                enddo
              end select
            else
              if (present(missingVal)) then
                do k = lb3(3),ub3(3)
                do j = lb3(2),ub3(2)
                do i = lb3(1),ub3(1)
                  if (dptr3(i,j,k).eq.missingVal) dptr3(i,j,k) = sptr3(i,j,k)
                enddo
                enddo
                enddo
              else
                dptr3(lb3(1):ub3(1),lb3(2):ub3(2),lb3(3):ub3(3)) = &
                  sptr3(lb3(1):ub3(1),lb3(2):ub3(2),lb3(3):ub3(3))
              endif
            endif

          endif

        enddo
!/
!/ End of FieldCopy -------------------------------------------------- /
!/
      end subroutine FieldCopy
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "FieldGather"
      subroutine FieldGather(field, n1, n2, fout, rc)
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         DD-MMM-YYYY |
!/                  +-----------------------------------+
!/
!/    DD-MMM-YYYY : Origination.                        ( version 5.XX )
!/
!  1. Purpose :
!
!     All gather of ESMF field
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      NONE
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_Field)                 :: field
      integer                          :: n1, n2
      real                             :: fout(n1,n2)
      integer,               optional  :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      integer :: k
      real(ESMF_KIND_RX) :: floc(n1,n2)
!
! -------------------------------------------------------------------- /
! Gather Field
!
      if (present(rc)) rc = ESMF_SUCCESS

      do k = 0,npet-1
        call ESMF_FieldGather( field,  floc, rootPet=k, vm=vm, rc=rc )
        if (ESMF_LogFoundError(rc, PASSTHRU)) return
      enddo
      fout(1:n1,1:n2) = floc(1:n1,1:n2)
!/
!/ End of FieldGather ------------------------------------------------ /
!/
      end subroutine FieldGather
!/ ------------------------------------------------------------------- /
#undef METHOD
#define METHOD "LocalRoutine"
      subroutine LocalRoutine ( gcomp, rc )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        T. J. Campbell, NRL        |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         DD-MMM-YYYY |
!/                  +-----------------------------------+
!/
!/    DD-MMM-YYYY : Origination.                        ( version 5.XX )
!/
!  1. Purpose :
!
!     A local module routine
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       gcomp     Type   I/O Gridded component
!       rc        Int.   O   Return code
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      NONE
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      type(ESMF_GridComp) :: gcomp
      integer,intent(out) :: rc
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      character(ESMF_MAXSTR) :: cname
!
! -------------------------------------------------------------------- /
! Prep
!
      rc = ESMF_FAILURE
      call ESMF_GridCompGet(gcomp, name=cname, rc=rc)
      if (ESMF_LogFoundError(rc, PASSTHRU)) return
      if (verbose) call ESMF_LogWrite(trim(cname)// &
        ': entered LocalRoutine', ESMF_LOGMSG_INFO)
!
! -------------------------------------------------------------------- /
! Insert sections here
!

!
! -------------------------------------------------------------------- /
! Post
!
      rc = ESMF_SUCCESS
      if (verbose) call ESMF_LogWrite(trim(cname)// &
        ': leaving LocalRoutine', ESMF_LOGMSG_INFO)
!/
!/ End of LocalRoutine ----------------------------------------------- /
!/
      end subroutine LocalRoutine
!/ ------------------------------------------------------------------- /
!/
!/ End of module WMESMFMD -------------------------------------------- /
!/
      end module WMESMFMD
