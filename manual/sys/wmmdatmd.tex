\subsubsection{Data in {\F wmmdatmd}.} \label{sub:mdatmd}

The module {\F wmmdatmd} in the file {\file wmmdatmd.ftn} contains the
input data for the wave model.  First several variables and parameters
embedded in the module are defined:

\begin{vlist}
\vit{nmdata}{i }{Number of models in array dim.}
\vit{imdata}{i }{Selected model in data structure.}
\vit{mdsi  }{i }{Unit number for input file.}
\vit{mdso  }{i }{Unit number for output (log file).}
\vit{mdss  }{i }{Unit number for output (screen).}
\vit{mdst  }{i }{Unit number for test output.}
\vit{mdse  }{i }{Unit number for error output.}
\vit{      }{ }{These outputs correspond to similar unit numbers as
                defined per grid, but are used for multi-grid routines
                only.}
\vit{mdsp  }{i }{Unit number for profiling.}
\vit{mdsup }{i }{Unit number for unified point output.}
\vit{mdsf  }{ia}{Unit numbers for input files.}
\vit{nmproc}{i }{Number of processors (for total multi- grid model).}
\vit{improc}{i }{Corresponding actual processor number.}
\vit{nmplog, nmpscr, nmptst, nmperr, nmpupt}{}{}
\vit{      }{i }{Processors in {\F nmproc} designated for the above
                 output units numbers.}
\vit{stime }{ia}{Model run starting time.}
\vit{etime }{ia}{Model run ending time.}
\vit{tsync }{ia}{Synchronization time for grids.}
\vit{tmax  }{ia}{Maximum next time per grid.}
\vit{toutp }{ia}{Next output time for grids.}
\vit{tdata }{ia}{Time for which data is available.}
\vit{nrgrd }{i }{Number of grids.}
\vit{nrinp }{i }{Number of input grids.}
\vit{nrgrp }{i }{Number of groups.}
\vit{nmvmax}{i }{Number of moving grid data.}
\vit{grank }{ia}{Rank number for grid.}
\vit{grgrp }{ia}{Group number for grid.}
\vit{ingrp }{ia}{Grids in group, element 0 is number.}
\vit{grdhgh, grdeql, grdlow}{}{}
\vit{      }{ia}{Dependent grids with higher, same or lower rank number,
                 element 0 is number.}
\vit{allprc}{ia}{Map of processors in {\F mpi\_comm\_mwave} for all
                 individual grids.}
\vit{modmap}{ia}{Map which model is running where in {\F mpi\_comm\_mwave}
                 each group.}
\vit{grstat}{ia}{Grid computation status indicator.}
\vit{dtres }{ra}{Residual of time step.}
\vit{nbi2g }{ia}{Map cross-referencing how many spectra echo grid provides
                 to boundary cond. for other grids.}
\vit{respec}{la}{Map for need to convert spectra between grids.}
\vit{bcdump}{la}{Flag for dumping internal bound. data.}
\vit{inpmap}{ia}{Map for external input grids.}
\vit{idinp }{ca}{Input field identifiers.}
\vit{clkt0, clkinc, clkmax}{}{}
\vit{       }{i }{Global wall clock parameters,}

\vit{flgbdi}{l }{Flag for initialization of boundary distance maps.}
\vit{flghgn}{l }{Flags for using mask for computations and output for
                 areas of grid overlap.}
\vit{iflsti}{la}{Flags for last ice per grid.}
\vit{iflstl}{la}{Flags for last level per grid.}

\vit{mpi\_comm\_mwave}{}{}
\vit{      }{i }{MPI communicator.                    \hfill ({\F !/mpi})}
\vit{mtagn }{i }{"Zero" tag number for MPI.           \hfill ({\F !/mpi})}
\vit{nbista}{ia}{Status for gathering input boundary data.
                                                      \hfill ({\F !/mpi})}
\vit{hghsta}{ia}{Status for gathering high resolution data.
                                                      \hfill ({\F !/mpi})}
\vit{eqlsta}{ia}{Status for gath. data for equally ranked grids.
                                                      \hfill ({\F !/mpi})}
\vit{mdata }{t}{Data structure for grid dependent data.}
\vit{mdatas}{ta}{Array of data structures.}
\vit{bpst  }{t }{Data structure for staging boundary data.}
\vit{bpstge}{ta}{Array of data structures.}
\vit{hgst  }{t }{Data structure for staging 2-way nesting data.}
\vit{hgstge}{ta}{Array of data structures.}
\vit{eqst  }{t }{Data structure for staging equal grid reconciliation 
                 data.}
\vit{eqstge}{ta}{Array of data structures.}
\end{vlist}

\noindent
For each element of the type {\F mdata}, alias pointers are defined as in
the module {\F w3gdatmd}. These variables are:

\begin{vlist}
\vit{nbi2s }{ia}{Source information of boundary input data (grid number
                 and sea counter).}
\vit{mapbdi}{ra}{Map with distances to boundary.}
\vit{mapodi}{ra}{idem, open edges of grids.}
\vit{nrupts}{i }{Number of unified output points.}
\vit{uptmap}{ia}{Mapping of unified points to grids.}
\vit{mapmsk}{ia}{Mask corresponding to {\F flghg}{\it n} above.}
\vit{minit, mskini, fldat{\it n}}{}{}
\vit{      }{l }{Flags for array initializations.}
\vit{fllsti}{l }{Flag for last ice per grid.}
\vit{fllstl}{l }{Flag for last level per grid.}
\vit{nmv   }{i }{Number of moving grid data.}
\vit{tmv   }{ia}{Moving grid times.}
\vit{amv   }{ra}{Moving grid velocities.}
\vit{dmv   }{ra}{Moving grid directions.}
\vit{rcld  }{ia}{Record length for data assimilation.}
\vit{ndt   }{ia}{Number of data for data assimilation.}
\vit{datan }{ra}{Assimilation data.}
\vit{mpi\_comm\_grd, mpi\_comm\_bct}{}{}
\vit{      }{i }{Communicators for grid and broadcast. \hfill ({\F !/mpi})}
\vit{croot }{I }{"root" for {\F mpi\_comm\_grd} in {\F mpi\_comm\_mwave}.}
\vit{      }{  }{\strut                                \hfill ({\F !/mpi})}
\vit{fbcast}{l }{Flag for need of broadcasting data to processors that
                 are not in the communicator.          \hfill ({\F !/mpi})}
\vit{nrqbpg}{i }{Number of request handles.            \hfill ({\F !/mpi})}
\vit{irqbpg}{ia}{Request handles.                      \hfill ({\F !/mpi})}
\vit{nrqhgg}{i }{Number of request handles.            \hfill ({\F !/mpi})}
\vit{irqhgg}{ia}{Request handles.                      \hfill ({\F !/mpi})}
\vit{nrqeqg}{i }{Number of request handles.            \hfill ({\F !/mpi})}
\vit{irqeqg}{ia}{Request handles.                      \hfill ({\F !/mpi})}
\end{vlist}

\noindent
For each element of the type {\F bpst}, alias pointers are defined as in
the module {\F w3gdatmd}. These variables are:

\begin{vlist}
\vit{nrqbps}{i }{Number of request handles.            \hfill ({\F !/mpi})}
\vit{irqbps}{ia}{Request handles.                      \hfill ({\F !/mpi})}
\vit{vtime }{ia}{Valid time of data.}
\vit{stime }{ia}{Buffer for time for sending.          \hfill ({\F !/mpi})}
\vit{sbpi  }{ra}{Spectral data storage.}
\vit{tstore}{ra}{Spectral data buffer.                 \hfill ({\F !/mpi})}
\vit{init  }{l }{Flag for array allocation.}
\end{vlist}

\noindent
For each element of the type {\F hgst}, alias pointers are defined as in
the module {\F w3gdatmd}. These variables are:

\begin{vlist}
\vit{nrqhgs}{i }{Number of request handles.            \hfill ({\F !/mpi})}
\vit{irqhgs}{ia}{Request handles.                      \hfill ({\F !/mpi})}
\vit{nrqout}{i }{Number of local spectra.              \hfill ({\F !/mpi})}
\vit{outdat}{ia}{Corresponding data.                   \hfill ({\F !/mpi})}
\vit{ntot, nrec, nrc1, nsnd, nsn1, nsmx}{}{}
\vit{      }{i }{Counters for total data, send and received data with and
                 without masking.}
\vit{vtime }{ia}{Valid time of data.}
\vit{ljsea }{ia}{Local sea point counters.}
\vit{nravg }{ia}{Number of points in averaging.}
\vit{impsrc}{ia}{Source processor for data.}
\vit{itag  }{ia}{Communication tag.}
\vit{isend }{ia}{Composite of all data needed for send.}
\vit{wght  }{ra}{Weights in averaging.}
\vit{shgh  }{ra}{Staging area for spectra.}
\vit{tstore}{ra}{Staging area for spectra to be send out.
                                                       \hfill ({\F !/mpi})}
\vit{init  }{l }{Flag for array allocation.}
\end{vlist}

\noindent
For each element of the type {\F eqst}, alias pointers are defined as in
the module {\F w3gdatmd}. These variables are:

\begin{vlist}
\vit{nrqeqs}{i }{Number of request handles.            \hfill ({\F !/mpi})}
\vit{irqeqs}{ia}{Request handles.                      \hfill ({\F !/mpi})}
\vit{nrqout}{i }{Number of local spectra.              \hfill ({\F !/mpi})}
\vit{outdat}{ia}{Corresponding data.                   \hfill ({\F !/mpi})}
\vit{ntot, nrec, nsnd, navmax}{}{}
\vit{      }{i }{Counters for total data, send and received data.}
\vit{vtime }{ia}{Valid time of data.}
\vit{i/jsea}{ia}{Sea point counters.}
\vit{navg  }{ia}{Number of spectra in averaging.}
\vit{rip   }{ia}{Processor (receiving).}
\vit{rtg   }{ia}{Tag number (receiving).}
\vit{sis,sjs}{ia}{Sea point counter (sending).}
\vit{si1/2 }{ia}{Storage array counters (sending).}
\vit{sip   }{ia}{Processor (sending).}
\vit{stg   }{ia}{Tag (sending).}
\vit{seql  }{ra}{Staging array.}
\vit{wght  }{ra}{Weight between grids.}
\vit{wavg  }{ra}{Weight within grid.}
\vit{tstore}{ra}{Staging area for spectra to be send  out.
                                                       \hfill ({\F !/mpi})}
\vit{init  }{l }{Flag for array allocation.}
\end{vlist}